<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Numerics" #>
<#@ import namespace="System.Numerics" #>
<# int[] dimensionsToGenerate = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; #>
// Theta
// https://github.com/53V3N1X/SevenFramework
// LISCENSE: See "LISCENSE.md" in th root project directory.
// SUPPORT: See "SUPPORT.md" in the root project directory.

using System;
using Theta.Mathematics;
using System.Numerics;
using Theta.Code;

namespace Theta.Structures
{
    #region Notes

    // Visualizations--------------------------------------------------
    //
    // 1 Dimensional:
    //
    //  -1D |-----------|-----------| +1D
    //
    //       <--- 0 ---> <--- 1 --->
    //
    // 2 Dimensional:
    //       _____________________
    //      |          |          |  +2D
    //      |          |          |   ^
    //      |     2    |     3    |   |
    //      |          |          |   |
    //      |----------|----------|   |
    //      |          |          |   |
    //      |          |          |   |
    //      |     0    |     1    |   |
    //      |          |          |   v
    //      |__________|__________|  -2D
    //
    //       -1D <-----------> +1D 
    //
    // 3 Dimensional:
    //
    //            +3D     _____________________
    //           7       /         /          /|
    //          /       /    6    /     7    / |
    //         /       /---------/----------/  |
    //        /       /    2    /     3    /|  |
    //       L       /_________/__________/ |  |
    //    -3D       |          |          | | /|          +2D
    //              |          |          | |/ |           ^
    //              |     2    |     3    | /  |           |
    //              |          |          |/|  | <-- 5     |
    //              |----------|----------| |  |           |
    //              |          |          | |  /           |
    //              |          |          | | /            |
    //              |     0    |     1    | |/             |
    //              |          |          | /              v
    //              |__________|__________|/              -2D
    //	         
    //                   ^
    //                   |
    //                   4 (behind 0)
    //
    //               -1D <-----------> +1D
    //
    // Functionality------------------------------------------------------
    //
    // Load Variables:
    //
    // There are 2 load variables: 1) items-per-leaf and 2) tree-depth. These are
    // recomputed after additions and removals.
    //
    //   1) items-per-leaf
    //
    //      DESCRIPTION: indicates how many items can be placed in a leaf before a
    //      tree expansion should occur
    //
    //      EXAMPLE: if the current items-per-leaf value is 7 but we just added 8 
    //      items to a leaf, that leaf must become a branch and its contents must
    //      be divided up into new leaves of the new branch
    //
    //   2) tree-depth
    //
    //      DESCRIPTION: indicates the currently allowed tree depth preventing
    //      tree expansion when it would actually harm the structures algorithms
    //
    //      EXAMPLE: a leaf's count went over the items-per-leaf, but the tree is
    //      already incredibly imbalanced because we are at the currently allowed
    //      tree-depth, thus expansion does not occur; this often happens when the
    //      tree contains multiples of the same value

    #endregion

    public static class Omnitree
    {
        #region Spacial Types (Bound, Vector, Bounds)

        #region Shared

        public struct Bound<T>
        {
            private bool _exists;
            private T _value;

            public bool Exists { get { return this._exists; } }
            public T Value { get { return this._value; } }

            public Bound(T value)
            {
                this._exists = true;
                this._value = value;
            }

            internal Bound(bool exists, T value)
            {
                this._exists = exists;
                this._value = value;
            }

            public static Bound<T> None { get { return new Bound<T>(false, default(T)); } }

            public static implicit operator Bound<T>(T value)
            {
                return new Bound<T>(value);
            }
        }
        
        public delegate A MedianOverride<T, A, BoundsType>(BoundsType bounds, Stepper<T> values);

        #endregion

        #region N Dimensional

        public struct Vector
        {
            internal object[] _location;


            /// <summary>The locations along each axis.</summary>
            public object[] Location { get { return _location; } }


            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector Default
            {
                get { return new Vector(null); }
            }
            
            public Vector(params object[] location)
            {
                this._location = location.Clone() as object[];
            }
        }

        public struct Bounds
        {

            Bound<object>[] _min, _max;

            public Bound<object>[] Min { get { return this._min; } }
            public Bound<object>[] Max { get { return this._max; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds None(int dimensions)
            {
                Bound<object>[] min = new Bound<object>[dimensions];
                for (int i = 0; i < dimensions; i++)
                    min[i] = Bound<object>.None;
                Bound<object>[] max = new Bound<object>[dimensions];
                for (int i = 0; i < dimensions; i++)
                    max[i] = Bound<object>.None;
                return new Bounds(min, max);
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(Bound<object>[] min, Bound<object>[] max)
            {
                this._min = min.Clone() as Bound<object>[];
                this._max = max.Clone() as Bound<object>[];
            }
        }

        //public delegate void Location<T, object[]>();
        
        //public delegate void GetBounds<T, object[]>();

        #endregion
<# foreach (int i in dimensionsToGenerate) { #>

        #region <#= i #> Dimensional

        public struct Vector<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>
        {<# for (int j = 1; j <= i; j++) { #>

            internal A<#= j #> _axis<#= j #>;<# } #>

<# for (int j = 1; j <= i; j++) { #>

            /// <summary>The value along axis <#= j #>.</summary>
            public A<#= j #> Axis<#= j #> { get { return this._axis<#= j #>; } }<# } #>


            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>> Default
            {
                get { return new Vector<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(default(A1)<# for (int j = 2; j <= i; j++) { #>, default(A<#= j #>)<# } #>); }
            }

            /// <summary>A location along each axis.</summary>
<# for (int j = 1; j <= i; j++) { #>
            /// <param name="axis<#= j #>">The location along axis <#= j #>.</param><# } #>

            public Vector(A1 axis1<# for (int j = 2; j <= i; j++) { #>, A<#= j #> axis<#= j #><# } #>)
            {<# for (int j = 1; j <= i; j++) { #>

                this._axis<#= j #> = axis<#= j #>;<# } #>

            }
        }

        public struct Bounds<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>
        {<# for (int j = 1; j <= i; j++) { #>

            Bound<A<#= j #>> _min<#= j #>, _max<#= j #>;<# } #>

<# for (int j = 1; j <= i; j++) { #>

            public Bound<A<#= j #>> Min<#= j #> { get { return this._min<#= j #>; } }
            public Bound<A<#= j #>> Max<#= j #> { get { return this._max<#= j #>; } }<# } #>


            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>> None
            {
                get
                {
                    return new Bounds<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(
                        Bound<A1>.None, Bound<A1>.None<# for (int j = 2; j <= i; j++) { #>,
                        Bound<A<#= j #>>.None, Bound<A<#= j #>>.None<# } #>);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1<# for (int j = 2; j <= i; j++) { #>,
                Bound<A<#= j #>> min<#= j #>, Bound<A<#= j #>> max<#= j #><# } #>)
            {
<# for (int j = 1; j <= i; j++) { #>
                this._min<#= j #> = min<#= j #>;
                this._max<#= j #> = max<#= j #>;
<# } #>
            }
        }

        public delegate void Location<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(T element, out A1 axis1<# for (int j = 2; j <= i; j++) { #>, out A<#= j #> axis<#= j #><# } #>);

        public delegate void GetBounds<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(T element, out Bound<A1> min1, out Bound<A1> max1<# for (int j = 2; j <= i; j++) { #>, out Bound<A<#= j #>> min<#= j #>, out Bound<A<#= j #>> max<#= j #><# } #>);
        
        #endregion
<# } #>

        #endregion
    }<# foreach (int i in dimensionsToGenerate) { #>
<# // ------------------------------------------------------------------------------------------------------------------------------ #>
<# // PARAMETER/ARGUMENT CHAINS #>
<#      string chain_AxisX = "Axis1"; for (int j = 2; j <= i; j++) { chain_AxisX += ", Axis" + j; } #>
<#      string chain_axisX = "axis1"; for (int j = 2; j <= i; j++) { chain_axisX += ", axis" + j; } #>
<#      string chain_AxisX_axisX = "Axis1 axis1"; for (int j = 2; j <= i; j++) { chain_AxisX_axisX += ", Axis" + j + " axis" + j; } #>
<#      string chain_AxisX_minX_AxisX_maxX = "Axis1 min1, Axis1 max1"; for (int j = 2; j <= i; j++) { chain_AxisX_minX_AxisX_maxX += ", Axis" + j + " min" + j + ", Axis" + j + " max" + j; } #>
<#      string chain_BoundAxisX_minX_BoundAxisX_maxX = "Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1"; for (int j = 2; j <= i; j++) { chain_BoundAxisX_minX_BoundAxisX_maxX += ", Omnitree.Bound<Axis" + j + "> min" + j + ", Omnitree.Bound<Axis" + j + "> max" + j; } #>
<#      string chain_BoundAxisX_axisX = "Omnitree.Bound<Axis1> axis1"; for (int j = 2; j <= i; j++) { chain_BoundAxisX_axisX += ", Omnitree.Bound<Axis" + j + "> axis" + j; } #>
<#      string chain_minX_maxX = "min1, max1"; for (int j = 2; j <= i; j++) { chain_minX_maxX += ", min" + j + ", max" + j; } #>
<#      string chain_axisX_axisX = "axis1, axis1"; for (int j = 2; j <= i; j++) { chain_axisX_axisX += ", axis" + j + ", axis" + j; } #>
<#      string child_index_type; if (i <= 30) { child_index_type = "int"; } else if (i <= 60) { child_index_type = "long"; } else { child_index_type = "BigInteger"; } #>
<# // DOCUMENTATION #>
<#      string documentation_AxisX_axisX = string.Empty; for (int j = 1; j <= i; j++) { documentation_AxisX_axisX += "\n\t\t/// <param name=\"axis" + j + "\">The coordinate along the " + j + "D axis.</param>"; } documentation_AxisX_axisX = documentation_AxisX_axisX.Trim(); #>
<#      string documentation_AxisX_minX_AxisX_maxX = string.Empty; for (int j = 1; j <= i; j++) { documentation_AxisX_minX_AxisX_maxX += "\n\t\t/// <param name=\"min" + j + "\">The minimum coordinate of the space along the " + j + " axis.</param>\n\t\t/// <param name=\"max" + j + "\">The maximum coordinate of the space along the " + j + " axis.</param>"; } documentation_AxisX_minX_AxisX_maxX = documentation_AxisX_minX_AxisX_maxX.Trim(); #>
<#      string documentation_axisX = string.Empty; for (int j = 1; j <= i; j++) { documentation_axisX += "\n\t\t/// <param name=\"axis" + j + "\">The axis of the removal along the  " + j + "D axis.</param>"; } documentation_axisX = documentation_axisX.Trim(); #>
<# // ------------------------------------------------------------------------------------------------------------------------------ #>


    #region <#= i #> Dimensional

    public interface OmnitreePoints<T, <#= chain_AxisX #>> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[<#= chain_AxisX_axisX #>] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(<#= chain_AxisX_minX_AxisX_maxX #>);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Update(<#= chain_AxisX_minX_AxisX_maxX #>);

        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_axisX #>
        void Remove(<#= chain_AxisX_axisX #>);
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Remove(<#= chain_AxisX_minX_AxisX_maxX #>);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        <#= documentation_AxisX_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(<#= chain_AxisX_axisX #>, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Stepper(Step<T> step, <#= chain_AxisX_minX_AxisX_maxX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        StepStatus Stepper(StepBreak<T> step, <#= chain_AxisX_minX_AxisX_maxX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_axisX #>
        void Stepper(Step<T> step, <#= chain_AxisX_axisX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_axisX #>
        StepStatus Stepper(StepBreak<T> function, <#= chain_AxisX_axisX #>);

        #endregion
    }

    public class OmnitreePointsLinked<T, <#= chain_AxisX #>> : OmnitreePoints<T, <#= chain_AxisX #>>
    {
        private const int _dimensions = <#= i #>;
        internal static <#= child_index_type #> _children_per_node = (<#= child_index_type #>)BigInteger.Pow(2, <#= i #>);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1<# for (int j = 2; j <= i; j++) { #>, Axis<#= j #><# } #>> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

<# for (int j = 1; j <= i; j++) { #>
        private bool _defaultEquate<#= j #>;
        private Equate<Axis<#= j #>> _equate<#= j #>;
<# } #>

<# for (int j = 1; j <= i; j++) { #>
        private bool _defaultCompare<#= j #>;
        private Compare<Axis<#= j #>> _compare<#= j #>;
<# } #>

        // allows median overriding for custom optimizations
<# for (int j = 1; j <= i; j++) { #>
        private Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> _medianOverride<#= j #>;
<# } #>

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<<#= chain_AxisX #>> _bounds;
            internal Branch _parent;
            internal <#= child_index_type #> _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<<#= chain_AxisX #>> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public <#= child_index_type #> Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Branch parent, <#= child_index_type #> index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<<#= chain_AxisX #>> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<<#= chain_AxisX #>> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[<#= child_index_type #> child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Branch parent, <#= child_index_type #> index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Branch parent, <#= child_index_type #> index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, <#= chain_AxisX #>>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, <#= chain_AxisX #>> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
<# for (int j = 1; j <= i; j++) { #>
            this._defaultEquate<#= j #> = omnitree._defaultEquate<#= j #>;
            this._equate<#= j #> = omnitree._equate<#= j #>;
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._defaultCompare<#= j #> = omnitree._defaultCompare<#= j #>;
            this._compare<#= j #> = omnitree._compare<#= j #>;
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._medianOverride<#= j #> = omnitree._medianOverride<#= j #>;
<# } #>
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            bool defaultEquate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            bool defaultEquate<#= j #>,
            Equate<Axis<#= j #>> equateAxis<#= j #>,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            bool defaultCompare<#= j #>,
            Compare<Axis<#= j #>> compare<#= j #>,
<# } #>
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride<#= j #><# } #>)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
<# for (int j = 1; j <= i; j++) { #>
            Code.AssertArgNonNull(equateAxis<#= j #>, "equateAxis<#= j #>");
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            Code.AssertArgNonNull(compare<#= j #>, "compare<#= j #>");
<# } #>

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
<# for (int j = 1; j <= i; j++) { #>
            this._defaultEquate<#= j #> = defaultEquate<#= j #>;
            this._equate<#= j #> = equateAxis<#= j #>;
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._defaultCompare<#= j #> = defaultCompare<#= j #>;
            this._compare<#= j #> = compare<#= j #>;
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._medianOverride<#= j #> = medianOverride<#= j #>;
<# } #>

            this._top = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Equate<Axis<#= j #>> equateAxis<#= j #>,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,
<# } #>
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride<#= j #><# } #>)
            : this(
            locate,
            false,
            equate,
<# for (int j = 1; j <= i; j++) { #>
            false,
            equateAxis<#= j #>,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
            false,
            compare<#= j #>,
<# } #>
            medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            medianOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Equate<Axis<#= j #>> equateAxis<#= j #>,
<# } #>
            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                locate,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                false,
                equateAxis<#= j #>,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,
<# } #>
                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                locate,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,
<# } #>
                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,
<# } #>
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride<#= j #><# } #>)
            : this(
                locate,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,
<# } #>
                medianOverride1<# for (int j = 2; j <= i; j++) { #>,
                medianOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                locate,
                true,
                Theta.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,
<# } #>
                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,
<# } #>
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride<#= j #><# } #>)
            : this(
                locate,
                true,
                Theta.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,
<# } #>
                medianOverride1<# for (int j = 2; j <= i; j++) { #>,
                medianOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,
<# } #>
                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride<#= j #><# } #>)
            : this(
                locate,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,
<# } #>
                medianOverride1<# for (int j = 2; j <= i; j++) { #>,
                medianOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,
<# } #>
                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.MedianOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> medianOverride<#= j #><# } #>)
            : this(
                locate,
                true,
                Theta.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Theta.Equate.Default,
<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,
<# } #>
                medianOverride1<# for (int j = 2; j <= i; j++) { #>,
                medianOverride<#= j #><# } #>)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
<# for (int j = 1; j <= i; j++) { #>
        /// <param name="axis<#= j #>">The coordinate along axis <#= j #>.</param>
<# } #>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[<#= chain_AxisX_axisX #>]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, <#= chain_axisX #>); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, <#= chain_AxisX #>> Locate { get { return this._locate; } }

<# for (int j = 1; j <= i; j++) { #>
        /// <summary>The comparison function the Omnitree is using along the <#= j #>D axis.</summary>
        public Compare<Axis<#= j #>> Compare<#= j #> { get { return this._compare<#= j #>; } }
<# } #>

<# for (int j = 1; j <= i; j++) { #>
        /// <summary>The function for equating values along the <#= j #>D axis.</summary>
        public Equate<Axis<#= j #>> EquateAxis<#= j #> { get { return this._equate<#= j #>; } }
<# } #>

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<<#= chain_AxisX #>>.Default, Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                new_top.Count = (int)additions.Length;

<# for (int j = 1; j <= i; j++) { #>
                // prepare data for median computations
                BigArray<Axis<#= j #>> values<#= j #>;
                IAsyncResult result<#= j #> = null;
                if (this._medianOverride<#= j #> != null)
                    values<#= j #> = null;
                else
                {
                    values<#= j #> = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values<#= j #> = new BigArray<Axis<#= j #>>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values<#= j #>[i] = LocateVector(additions[i]).Axis<#= j #>;
                        Theta.Algorithms.Sort<Axis<#= j #>>.Merge(this._compare<#= j #>, (int i) => { return values<#= j #>[(ulong)i]; }, (int i, Axis<#= j #> value) => { values<#= j #>[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result<#= j #> = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
<# } #>

<# for (int j = 1; j <= i; j++) { #>
                if (this._medianOverride<#= j #> == null && allowMultithreading)
                    result<#= j #>.AsyncWaitHandle.WaitOne();
<# } #>

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, <# for (int j = 1; j <= i; j++) { #>int.MinValue, <# } #>(int)additions.Length, <# for (int j = 1; j <= i; j++) { #>(int index) => { return values<#= j #>[index]; }, <# } #>allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<<#= chain_AxisX #>>.Default, Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                new_top.Count = (int)additions.Length;

<# for (int j = 1; j <= i; j++) { #>
                // prepare data for median computations
                BigArray<Axis<#= j #>> values<#= j #>;
                IAsyncResult result<#= j #> = null;
                if (this._medianOverride<#= j #> != null)
                    values<#= j #> = null;
                else
                {
                    values<#= j #> = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values<#= j #> = new BigArray<Axis<#= j #>>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values<#= j #>[i] = LocateVector(additions[i]).Axis<#= j #>;
                        Theta.Algorithms.Sort<Axis<#= j #>>.Merge(this._compare<#= j #>, (int i) => { return values<#= j #>[(ulong)i]; }, (int i, Axis<#= j #> value) => { values<#= j #>[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result<#= j #> = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
<# } #>

<# for (int j = 1; j <= i; j++) { #>
                if (this._medianOverride<#= j #> == null && allowMultithreading)
                    result<#= j #>.AsyncWaitHandle.WaitOne();
<# } #>

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, <# for (int j = 1; j <= i; j++) { #>int.MinValue, <# } #>(int)additions.Length, <# for (int j = 1; j <= i; j++) { #>(int index) => { return values<#= j #>[index]; }, <# } #>allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, <#= child_index_type #> child, Stepper<T> additions, int parent_count, <# for (int j = 1; j <= i; j++) { #>int prevmed<#= j #>, <# } #>int initial_count, <# for (int j = 1; j <= i; j++) { #>Get<Axis<#= j #>> values<#= j #>, <# } #>bool allowMultithreading)
        {
<# for (int j = 1; j <= i; j++) { #>
            Axis<#= j #> pointOfDivision<#= j #>;
<# } #>

<# for (int j = 1; j <= i; j++) { #>
            int median_axis<#= j #>;
<# } #>
            GetMedianIndexes(initial_count, child, depth, <# for (int j = 1; j <= i; j++) { #>prevmed<#= j #>, <# } #>out median_axis1<# for (int j = 2; j <= i; j++) { #>, out median_axis<#= j #><# } #>);

<# for (int j = 1; j <= i; j++) { #>
            if (this._medianOverride<#= j #> != null)
                pointOfDivision<#= j #> = this._medianOverride<#= j #>(parent.Bounds, additions);
            else
                pointOfDivision<#= j #> = values<#= j #>(median_axis<#= j #>);
<# } #>

            parent.PointOfDivision = new Omnitree.Vector<<#= chain_AxisX #>>(pointOfDivision1<# for (int j = 2; j <= i; j++) { #>, pointOfDivision<#= j #><# } #>);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<<#= child_index_type #>, List<T>> collection_map = new System.Collections.Generic.Dictionary<<#= child_index_type #>, List<T>>();
            //additions((T value) => 
            //{
            //    <#= child_index_type #> index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<<#= child_index_type #>, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, <#= child_index_type #>>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, <#= child_index_type #>> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<<#= child_index_type #>, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, <#= child_index_type #>> collection_map = new MapHashLinked<List<T>, <#= child_index_type #>>();
            additions((T value) => 
            {
                <#= child_index_type #> index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((<#= child_index_type #> key) => { parent[key] = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, <#= child_index_type #>>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, <#= child_index_type #>> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, <#= child_index_type #>> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, <#= child_index_type #> child_index, int depth, Stepper<T> additions, int count, <# for (int j = 1; j <= i; j++) { #>int prevmed<#= j #>, <# } #>int initial_count, <# for (int j = 1; j <= i; j++) { #>Get<Axis<#= j #>> values<#= j #>, <# } #>bool allowMultithreading)
        {
            Omnitree.Bounds<<#= chain_AxisX #>> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<<#= chain_AxisX #>>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, <# for (int j = 1; j <= i; j++) { #>prevmed<#= j #>, <# } #>count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, <#= child_index_type #> child_index, int depth, <# for (int j = 1; j <= i; j++) { #>int previous<#= j #>, <# } #>out int index1<# for (int j = 2; j <= i; j++) { #>, out int index<#= j #><# } #>)
        {
            if (depth == 1)
            {
<# for (int j = 1; j <= i; j++) { #>
                index<#= j #> = (count - 1) / 2;
<# } #>
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

<# for (int j = i; j >= 1; j--) { #>
            if (child_index >= 1 << <#= j #>)
            {
                index<#= j #> = previous<#= j #> + mid_child_range;
                child_index -= 1 << <#= j #>;
            }
            else
            {
                index<#= j #> = previous<#= j #> - mid_child_range;
            }

<# } #>
        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<<#= chain_AxisX #>> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<<#= chain_AxisX #>> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    <#= child_index_type #> child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<<#= chain_AxisX #>> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                <#= child_index_type #> child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<<#= chain_AxisX #>> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
<# for (int j = 1; j <= i; j++) { #>
                Axis<#= j #>[] values<#= j #> = new Axis<#= j #>[leaf.Count];
<# } #>
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i]<# for (int j = 2; j <= i; j++) { #>, out values<#= j #>[i]<# } #>);
                // sort the values
<# for (int j = 1; j <= i; j++) { #>
                if (_defaultCompare<#= j #>) Array.Sort(values<#= j #>);
                else Array.Sort(values<#= j #>, Compare.ToSystemComparison(this._compare<#= j #>));
<# } #>
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<<#= chain_AxisX #>>(values1[index]<# for (int j = 2; j <= i; j++) { #>, values<#= j #>[index]<# } #>);
            }
            catch
            {
                // extract the values
<# for (int j = 1; j <= i; j++) { #>
                BigArray<Axis<#= j #>> values<#= j #> = new BigArray<Axis<#= j #>>(leaf.Count);
<# } #>
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
<# for (int j = 1; j <= i; j++) { #>
                    Axis<#= j #> value<#= j #>;
<# } #>
                    this._locate(for_current.Value, out value1<# for (int j = 2; j <= i; j++) { #>, out value<#= j #><# } #>);
<# for (int j = 1; j <= i; j++) { #>
                    values<#= j #>[i] = value<#= j #>;
<# } #>
                }
                // sort the values
<# for (int j = 1; j <= i; j++) { #>
                if (_defaultCompare<#= j #>) Theta.Algorithms.Sort<Axis<#= j #>>.Merge(Compare.Default, (int sorting_index) => { return values<#= j #>[sorting_index]; }, (int sorting_index, Axis<#= j #> axis<#= j #>) => { values<#= j #>[sorting_index] = axis<#= j #>; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis<#= j #>>.Merge(_compare<#= j #>, (int sorting_index) => { return values<#= j #>[sorting_index]; }, (int sorting_index, Axis<#= j #> axis<#= j #>) => { values<#= j #>[sorting_index] = axis<#= j #>; }, 0, (int)values1.Length);
<# } #>
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<<#= chain_AxisX #>>(values1[index]<# for (int j = 2; j <= i; j++) { #>, values<#= j #>[index]<# } #>);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<<#= chain_AxisX #>> DetermineChildBounds(Branch branch, <#= child_index_type #> child_index)
        {
<# for (int j = i; j >= 1; j--) { #>
            Omnitree.Bound<Axis<#= j #>> min<#= j #>, max<#= j #>;
            if (child_index >= 1 << 2)
            {
                min<#= j #> = branch.PointOfDivision.Axis<#= j #>;
                max<#= j #> = branch.Bounds.Max<#= j #>;
                child_index -= 1 << 2;
            }
            else
            {
                min<#= j #> = branch.Bounds.Min<#= j #>;
                max<#= j #> = branch.PointOfDivision.Axis<#= j #>;
            }
<# } #>
            return new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, <#= chain_AxisX #>> Clone()
        {
            return new OmnitreePointsLinked<T, <#= chain_AxisX #>>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_AxisX_axisX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_BoundAxisX_axisX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<<#= chain_AxisX #>>(bounds.Min1.Value<# for (int j = 2; j <= i; j++) { #>, bounds.Min<#= j #>.Value<# } #>));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<<#= chain_AxisX #>> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Update(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Update(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_axisX #>
        public void Update(<#= chain_AxisX_axisX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_axisX #>
        public void Update(<#= chain_BoundAxisX_axisX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), this._top, 0);
        }
        private int Update(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<<#= chain_AxisX #>> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_axisX #>
        public void Remove(<#= chain_BoundAxisX_axisX #>)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        private int Remove(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_BoundAxisX_axisX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), where);
        }
        private int Remove(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
<# for (int j = 1; j <= i; j++) { #>
            Axis<#= j #> axis<#= j #>;
<# } #>
            this._locate(removal, out axis1<# for (int j = 2; j <= i; j++) { #>, out axis<#= j #><# } #>);
            this.Remove(<# for (int j = 1; j <= i; j++) { #>axis<#= j #>, <# } #>(T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_axisX #>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1<# for (int j = 2; j <= i; j++) { #>, Axis<#= j #> axis<#= j #><# } #>)
        {
            this.Remove(this._top, new Omnitree.Vector<<#= chain_AxisX #>>(axis1<# for (int j = 2; j <= i; j++) { #>, axis<#= j #><# } #>));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_AxisX_axisX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<<#= chain_AxisX #>> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Stepper(Step<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Stepper(Step<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus Stepper(StepBreak<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus Stepper(StepBreak<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_axisX #>
        public void Stepper(Step<T> function, <#= chain_AxisX_axisX #>)
        {
            Stepper(function, _top, new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_axisX #>
        public StepStatus Stepper(StepBreak<T> function, <#= chain_AxisX_axisX #>)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (bounds.Min<#= j #>.Exists && bounds.Max<#= j #>.Exists && this._compare<#= j #>(bounds.Min<#= j #>.Value, vector.Axis<#= j #>) != Comparison.Greater && (this._compare<#= j #>(bounds.Max<#= j #>.Value, vector.Axis<#= j #>) != Comparison.Less))
                return true;
<# } #>
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private <#= child_index_type #> DetermineChildIndex(Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            <#= child_index_type #> child = 0;
<# for (int j = 1; j <= i; j++) { #>
            if (!(this._compare<#= j #>(vector.Axis<#= j #>, pointOfDivision.Axis<#= j #>) == Comparison.Less))
                child += 1 << <#= j - 1 #>;
<# } #>
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, <#= child_index_type #> child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<<#= chain_AxisX #>> a, Omnitree.Bounds<<#= chain_AxisX #>> b)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (a.Max<#= j #>.Exists && b.Min<#= j #>.Exists && this._compare<#= j #>(a.Max<#= j #>.Value, b.Min<#= j #>.Value) == Comparison.Less)
                return false;
            else if (a.Min<#= j #>.Exists && b.Max<#= j #>.Exists && this._compare<#= j #>(a.Min<#= j #>.Value, b.Max<#= j #>.Value) == Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            // if the location is not outside the bounds, it must be inside
<# for (int j = 1; j <= i; j++) { #>
            if (bounds.Min<#= j #>.Exists && this._compare<#= j #>(vector.Axis<#= j #>, bounds.Min<#= j #>.Value) == Comparison.Less)
                return false;
            else if (bounds.Max<#= j #>.Exists && this._compare<#= j #>(vector.Axis<#= j #>, bounds.Max<#= j #>.Value) == Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<<#= chain_AxisX #>> a, Omnitree.Bounds<<#= chain_AxisX #>> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists)<# for (int j = 2; j <= i; j++) { #> || (a.Min<#= j #>.Exists && !b.Min<#= j #>.Exists)<# } #>)
                return false;
<# for (int j = 1; j <= i; j++) { #>
            if (b.Min<#= j #>.Exists && a.Min<#= j #>.Exists && this._compare<#= j #>(a.Min<#= j #>.Value, b.Min<#= j #>.Value) != Comparison.Less)
                return false;
            if (b.Max<#= j #>.Exists && a.Max<#= j #>.Exists && this._compare<#= j #>(a.Max<#= j #>.Value, b.Max<#= j #>.Value) != Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<<#= chain_AxisX #>> a, Omnitree.Vector<<#= chain_AxisX #>> b)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (!this._equate<#= j #>(a.Axis<#= j #>, b.Axis<#= j #>))
                return false;
<# } #>
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<<#= child_index_type #>>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<<#= chain_AxisX #>> LocateVector(T value)
        {
<# for (int j = 1; j <= i; j++) { #>
            Axis<#= j #> axis<#= j #>;
<# } #>
            this._locate(value, out axis1<# for (int j = 2; j <= i; j++) { #>, out axis<#= j #><# } #>);
            return new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>);
        }

        #endregion

        #endregion
    }

    #endregion<# } #>

}