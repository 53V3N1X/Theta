// Theta
// https://github.com/53V3N1X/SevenFramework
// LISCENSE: See "LISCENSE.md" in th root project directory.
// SUPPORT: See "SUPPORT.md" in the root project directory.

using System;
using Theta.Mathematics;
using System.Numerics;

namespace Theta.Structures
{
    #region Notes

    // Visualizations--------------------------------------------------
    //
    // 1 Dimensional:
    //
    //  -1D |-----------|-----------| +1D
    //
    //       <--- 0 ---> <--- 1 --->
    //
    // 2 Dimensional:
    //       _____________________
    //      |          |          |  +2D
    //      |          |          |   ^
    //      |     2    |     3    |   |
    //      |          |          |   |
    //      |----------|----------|   |
    //      |          |          |   |
    //      |          |          |   |
    //      |     0    |     1    |   |
    //      |          |          |   v
    //      |__________|__________|  -2D
    //
    //       -1D <-----------> +1D 
    //
    // 3 Dimensional:
    //
    //            +3D     _____________________
    //           7       /         /          /|
    //          /       /    6    /     7    / |
    //         /       /---------/----------/  |
    //        /       /    2    /     3    /|  |
    //       L       /_________/__________/ |  |
    //    -3D       |          |          | | /|          +2D
    //              |          |          | |/ |           ^
    //              |     2    |     3    | /  |           |
    //              |          |          |/|  | <-- 5     |
    //              |----------|----------| |  |           |
    //              |          |          | |  /           |
    //              |          |          | | /            |
    //              |     0    |     1    | |/             |
    //              |          |          | /              v
    //              |__________|__________|/              -2D
    //	         
    //                   ^
    //                   |
    //                   4 (behind 0)
    //
    //               -1D <-----------> +1D
    //
    // Functionality------------------------------------------------------
    //
    // Load Variables:
    //
    // There are 2 load variables: 1) items-per-leaf and 2) tree-depth. These are
    // recomputed after additions and removals.
    //
    //   1) items-per-leaf
    //
    //      DESCRIPTION: indicates how many items can be placed in a leaf before a
    //      tree expansion should occur
    //
    //      EXAMPLE: if the current items-per-leaf value is 7 but we just added 8 
    //      items to a leaf, that leaf must become a branch and its contents must
    //      be divided up into new leaves of the new branch
    //
    //   2) tree-depth
    //
    //      DESCRIPTION: indicates the currently allowed tree depth preventing
    //      tree expansion when it would actually harm the structures algorithms
    //
    //      EXAMPLE: a leaf's count went over the items-per-leaf, but the tree is
    //      already incredibly imbalanced because we are at the currently allowed
    //      tree-depth, thus expansion does not occur; this often happens when the
    //      tree contains multiples of the same value

    #endregion

    public static class Omnitree
    {
        #region Spacial Types (Bound, Vector, Bounds)

        #region Shared

        public struct Bound<T>
        {
            private bool _exists;
            private T _value;

            public bool Exists { get { return this._exists; } }
            public T Value { get { return this._value; } }

            public Bound(T value)
            {
                this._exists = true;
                this._value = value;
            }

            internal Bound(bool exists, T value)
            {
                this._exists = exists;
                this._value = value;
            }

            public static Bound<T> None { get { return new Bound<T>(false, default(T)); } }

            public static implicit operator Bound<T>(T value)
            {
                return new Bound<T>(value);
            }
        }
        
        public delegate A MedianOverride<T, A, BoundsType>(BoundsType bounds, Stepper<T> values);

        #endregion

        #region N Dimensional

        public struct Vector
        {
            internal object[] _location;


            /// <summary>The locations along each axis.</summary>
            public object[] Location { get { return _location; } }


            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector Default
            {
                get { return new Vector(null); }
            }
            
            public Vector(params object[] location)
            {
                this._location = location.Clone() as object[];
            }
        }

        public struct Bounds
        {

            Bound<object>[] _min, _max;

            public Bound<object>[] Min { get { return this._min; } }
            public Bound<object>[] Max { get { return this._max; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds None(int dimensions)
            {
                Bound<object>[] min = new Bound<object>[dimensions];
                for (int i = 0; i < dimensions; i++)
                    min[i] = Bound<object>.None;
                Bound<object>[] max = new Bound<object>[dimensions];
                for (int i = 0; i < dimensions; i++)
                    max[i] = Bound<object>.None;
                return new Bounds(min, max);
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(Bound<object>[] min, Bound<object>[] max)
            {
                this._min = min.Clone() as Bound<object>[];
                this._max = max.Clone() as Bound<object>[];
            }
        }

        //public delegate void Location<T, object[]>();
        
        //public delegate void GetBounds<T, object[]>();

        #endregion

        #region 1 Dimensional

        public struct Vector<A1>
        {
            internal A1 _axis1;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1> Default
            {
                get { return new Vector<A1>(default(A1)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            public Vector(A1 axis1)
            {
                this._axis1 = axis1;
            }
        }

        public struct Bounds<A1>
        {
            Bound<A1> _min1, _max1;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1> None
            {
                get
                {
                    return new Bounds<A1>(
                        Bound<A1>.None, Bound<A1>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1)
            {
                this._min1 = min1;
                this._max1 = max1;
            }
        }

        public delegate void Location<T, A1>(T element, out A1 axis1);

        public delegate void GetBounds<T, A1>(T element, out Bound<A1> min1, out Bound<A1> max1);
        
        #endregion

        #region 2 Dimensional

        public struct Vector<A1, A2>
        {
            internal A1 _axis1;
            internal A2 _axis2;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2> Default
            {
                get { return new Vector<A1, A2>(default(A1), default(A2)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>
            public Vector(A1 axis1, A2 axis2)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
            }
        }

        public struct Bounds<A1, A2>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2> None
            {
                get
                {
                    return new Bounds<A1, A2>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
            }
        }

        public delegate void Location<T, A1, A2>(T element, out A1 axis1, out A2 axis2);

        public delegate void GetBounds<T, A1, A2>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2);
        
        #endregion

        #region 3 Dimensional

        public struct Vector<A1, A2, A3>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3> Default
            {
                get { return new Vector<A1, A2, A3>(default(A1), default(A2), default(A3)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
            }
        }

        public struct Bounds<A1, A2, A3>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3> None
            {
                get
                {
                    return new Bounds<A1, A2, A3>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
            }
        }

        public delegate void Location<T, A1, A2, A3>(T element, out A1 axis1, out A2 axis2, out A3 axis3);

        public delegate void GetBounds<T, A1, A2, A3>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3);
        
        #endregion

        #region 4 Dimensional

        public struct Vector<A1, A2, A3, A4>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4> Default
            {
                get { return new Vector<A1, A2, A3, A4>(default(A1), default(A2), default(A3), default(A4)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
            }
        }

        public struct Bounds<A1, A2, A3, A4>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4);

        public delegate void GetBounds<T, A1, A2, A3, A4>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4);
        
        #endregion

        #region 5 Dimensional

        public struct Vector<A1, A2, A3, A4, A5>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5>(default(A1), default(A2), default(A3), default(A4), default(A5)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>            /// <param name="axis5">The location along axis 5.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5);
        
        #endregion

        #region 6 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>            /// <param name="axis5">The location along axis 5.</param>            /// <param name="axis6">The location along axis 6.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6);
        
        #endregion

        #region 7 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6, A7>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;
            internal A7 _axis7;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }
            /// <summary>The value along axis 7.</summary>
            public A7 Axis7 { get { return this._axis7; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6, A7> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6, A7>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6), default(A7)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>            /// <param name="axis5">The location along axis 5.</param>            /// <param name="axis6">The location along axis 6.</param>            /// <param name="axis7">The location along axis 7.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6, A7 axis7)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
                this._axis7 = axis7;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6, A7>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;
            Bound<A7> _min7, _max7;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }
            public Bound<A7> Min7 { get { return this._min7; } }
            public Bound<A7> Max7 { get { return this._max7; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6, A7> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6, A7>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None,
                        Bound<A7>.None, Bound<A7>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6,
                Bound<A7> min7, Bound<A7> max7)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
                this._min7 = min7;
                this._max7 = max7;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6, A7>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6, out A7 axis7);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6, A7>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6, out Bound<A7> min7, out Bound<A7> max7);
        
        #endregion

        #region 8 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6, A7, A8>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;
            internal A7 _axis7;
            internal A8 _axis8;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }
            /// <summary>The value along axis 7.</summary>
            public A7 Axis7 { get { return this._axis7; } }
            /// <summary>The value along axis 8.</summary>
            public A8 Axis8 { get { return this._axis8; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6, A7, A8> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6, A7, A8>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6), default(A7), default(A8)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>            /// <param name="axis5">The location along axis 5.</param>            /// <param name="axis6">The location along axis 6.</param>            /// <param name="axis7">The location along axis 7.</param>            /// <param name="axis8">The location along axis 8.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6, A7 axis7, A8 axis8)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
                this._axis7 = axis7;
                this._axis8 = axis8;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6, A7, A8>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;
            Bound<A7> _min7, _max7;
            Bound<A8> _min8, _max8;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }
            public Bound<A7> Min7 { get { return this._min7; } }
            public Bound<A7> Max7 { get { return this._max7; } }
            public Bound<A8> Min8 { get { return this._min8; } }
            public Bound<A8> Max8 { get { return this._max8; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6, A7, A8> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6, A7, A8>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None,
                        Bound<A7>.None, Bound<A7>.None,
                        Bound<A8>.None, Bound<A8>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6,
                Bound<A7> min7, Bound<A7> max7,
                Bound<A8> min8, Bound<A8> max8)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
                this._min7 = min7;
                this._max7 = max7;
                this._min8 = min8;
                this._max8 = max8;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6, A7, A8>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6, out A7 axis7, out A8 axis8);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6, A7, A8>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6, out Bound<A7> min7, out Bound<A7> max7, out Bound<A8> min8, out Bound<A8> max8);
        
        #endregion

        #region 9 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6, A7, A8, A9>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;
            internal A7 _axis7;
            internal A8 _axis8;
            internal A9 _axis9;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }
            /// <summary>The value along axis 7.</summary>
            public A7 Axis7 { get { return this._axis7; } }
            /// <summary>The value along axis 8.</summary>
            public A8 Axis8 { get { return this._axis8; } }
            /// <summary>The value along axis 9.</summary>
            public A9 Axis9 { get { return this._axis9; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6, A7, A8, A9> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6, A7, A8, A9>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6), default(A7), default(A8), default(A9)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>            /// <param name="axis5">The location along axis 5.</param>            /// <param name="axis6">The location along axis 6.</param>            /// <param name="axis7">The location along axis 7.</param>            /// <param name="axis8">The location along axis 8.</param>            /// <param name="axis9">The location along axis 9.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6, A7 axis7, A8 axis8, A9 axis9)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
                this._axis7 = axis7;
                this._axis8 = axis8;
                this._axis9 = axis9;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6, A7, A8, A9>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;
            Bound<A7> _min7, _max7;
            Bound<A8> _min8, _max8;
            Bound<A9> _min9, _max9;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }
            public Bound<A7> Min7 { get { return this._min7; } }
            public Bound<A7> Max7 { get { return this._max7; } }
            public Bound<A8> Min8 { get { return this._min8; } }
            public Bound<A8> Max8 { get { return this._max8; } }
            public Bound<A9> Min9 { get { return this._min9; } }
            public Bound<A9> Max9 { get { return this._max9; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6, A7, A8, A9> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6, A7, A8, A9>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None,
                        Bound<A7>.None, Bound<A7>.None,
                        Bound<A8>.None, Bound<A8>.None,
                        Bound<A9>.None, Bound<A9>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6,
                Bound<A7> min7, Bound<A7> max7,
                Bound<A8> min8, Bound<A8> max8,
                Bound<A9> min9, Bound<A9> max9)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
                this._min7 = min7;
                this._max7 = max7;
                this._min8 = min8;
                this._max8 = max8;
                this._min9 = min9;
                this._max9 = max9;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6, A7, A8, A9>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6, out A7 axis7, out A8 axis8, out A9 axis9);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6, A7, A8, A9>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6, out Bound<A7> min7, out Bound<A7> max7, out Bound<A8> min8, out Bound<A8> max8, out Bound<A9> min9, out Bound<A9> max9);
        
        #endregion

        #region 10 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;
            internal A7 _axis7;
            internal A8 _axis8;
            internal A9 _axis9;
            internal A10 _axis10;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }
            /// <summary>The value along axis 7.</summary>
            public A7 Axis7 { get { return this._axis7; } }
            /// <summary>The value along axis 8.</summary>
            public A8 Axis8 { get { return this._axis8; } }
            /// <summary>The value along axis 9.</summary>
            public A9 Axis9 { get { return this._axis9; } }
            /// <summary>The value along axis 10.</summary>
            public A10 Axis10 { get { return this._axis10; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6), default(A7), default(A8), default(A9), default(A10)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>            /// <param name="axis2">The location along axis 2.</param>            /// <param name="axis3">The location along axis 3.</param>            /// <param name="axis4">The location along axis 4.</param>            /// <param name="axis5">The location along axis 5.</param>            /// <param name="axis6">The location along axis 6.</param>            /// <param name="axis7">The location along axis 7.</param>            /// <param name="axis8">The location along axis 8.</param>            /// <param name="axis9">The location along axis 9.</param>            /// <param name="axis10">The location along axis 10.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6, A7 axis7, A8 axis8, A9 axis9, A10 axis10)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
                this._axis7 = axis7;
                this._axis8 = axis8;
                this._axis9 = axis9;
                this._axis10 = axis10;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;
            Bound<A7> _min7, _max7;
            Bound<A8> _min8, _max8;
            Bound<A9> _min9, _max9;
            Bound<A10> _min10, _max10;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }
            public Bound<A7> Min7 { get { return this._min7; } }
            public Bound<A7> Max7 { get { return this._max7; } }
            public Bound<A8> Min8 { get { return this._min8; } }
            public Bound<A8> Max8 { get { return this._max8; } }
            public Bound<A9> Min9 { get { return this._min9; } }
            public Bound<A9> Max9 { get { return this._max9; } }
            public Bound<A10> Min10 { get { return this._min10; } }
            public Bound<A10> Max10 { get { return this._max10; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None,
                        Bound<A7>.None, Bound<A7>.None,
                        Bound<A8>.None, Bound<A8>.None,
                        Bound<A9>.None, Bound<A9>.None,
                        Bound<A10>.None, Bound<A10>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6,
                Bound<A7> min7, Bound<A7> max7,
                Bound<A8> min8, Bound<A8> max8,
                Bound<A9> min9, Bound<A9> max9,
                Bound<A10> min10, Bound<A10> max10)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
                this._min7 = min7;
                this._max7 = max7;
                this._min8 = min8;
                this._max8 = max8;
                this._min9 = min9;
                this._max9 = max9;
                this._min10 = min10;
                this._max10 = max10;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6, out A7 axis7, out A8 axis8, out A9 axis9, out A10 axis10);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6, out Bound<A7> min7, out Bound<A7> max7, out Bound<A8> min8, out Bound<A8> max8, out Bound<A9> min9, out Bound<A9> max9, out Bound<A10> min10, out Bound<A10> max10);
        
        #endregion

        #endregion
    }

    #region 1 Dimensional

    public interface OmnitreePoints<T, Axis1> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Update(Axis1 min1, Axis1 max1);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        void Remove(Axis1 axis1);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Remove(Axis1 min1, Axis1 max1);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1> : OmnitreePoints<T, Axis1>
    {
        private const int _dimensions = 1;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 1);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> _medianOverride1;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._medianOverride1 = omnitree._medianOverride1;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> medianOverride1)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(compare1, "compare1");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._medianOverride1 = medianOverride1;

            this._top = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Compare<Axis1> compare1,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> medianOverride1)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            compare1,
            medianOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Compare<Axis1> compare1)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                compare1,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,
            Compare<Axis1> compare1)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> medianOverride1)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                medianOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Compare<Axis1> compare1)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Compare<Axis1> compare1,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> medianOverride1)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                medianOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> medianOverride1)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                medianOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1>> medianOverride1)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                medianOverride1)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1>.Default, Omnitree.Bounds<Axis1>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1>.Default, Omnitree.Bounds<Axis1>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int initial_count, Get<Axis1> values1, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;

            int median_axis1;
            GetMedianIndexes(initial_count, child, depth, prevmed1, out median_axis1);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            parent.PointOfDivision = new Omnitree.Vector<Axis1>(pointOfDivision1);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, initial_count, values1, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int initial_count, Get<Axis1> values1, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, count, values1, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, out int index1)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1>(values1[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    this._locate(for_current.Value, out value1);
                    values1[i] = value1;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1>(values1[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1>(min1, max1);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1>(bounds.Min1.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Update(Axis1 min1, Axis1 max1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Update(Axis1 axis1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(axis1, axis1), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            this._locate(removal, out axis1);
            this.Remove(axis1, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1>(axis1));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1>(axis1), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1>(axis1));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1>(axis1));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Vector<Axis1> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1> LocateVector(T value)
        {
            Axis1 axis1;
            this._locate(value, out axis1);
            return new Omnitree.Vector<Axis1>(axis1);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 2 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2> : OmnitreePoints<T, Axis1, Axis2>
    {
        private const int _dimensions = 2;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 2);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> _medianOverride2;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> medianOverride2)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> medianOverride2)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            compare1,
            false,
            compare2,
            medianOverride1,
            medianOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                compare1,
                false,
                compare2,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> medianOverride2)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                medianOverride1,
                medianOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> medianOverride2)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                medianOverride1,
                medianOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> medianOverride2)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> medianOverride2)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2>.Default, Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2>.Default, Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int initial_count, Get<Axis1> values1, Get<Axis2> values2, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;

            int median_axis1;
            int median_axis2;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, out median_axis1, out median_axis2);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2>(pointOfDivision1, pointOfDivision2);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int initial_count, Get<Axis1> values1, Get<Axis2> values2, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, count, values1, values2, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, out int index1, out int index2)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2>(values1[index], values2[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    this._locate(for_current.Value, out value1, out value2);
                    values1[i] = value1;
                    values2[i] = value2;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2>(values1[index], values2[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2>(bounds.Min1.Value, bounds.Min2.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            this._locate(removal, out axis1, out axis2);
            this.Remove(axis1, axis2, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Vector<Axis1, Axis2> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            this._locate(value, out axis1, out axis2);
            return new Omnitree.Vector<Axis1, Axis2>(axis1, axis2);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 3 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3> : OmnitreePoints<T, Axis1, Axis2, Axis3>
    {
        private const int _dimensions = 3;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 3);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> _medianOverride3;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride3)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride3)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            medianOverride1,
            medianOverride2,
            medianOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride3)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                medianOverride1,
                medianOverride2,
                medianOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride3)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                medianOverride1,
                medianOverride2,
                medianOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride3)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> medianOverride3)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, out median_axis1, out median_axis2, out median_axis3);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3>(pointOfDivision1, pointOfDivision2, pointOfDivision3);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, count, values1, values2, values3, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, out int index1, out int index2, out int index3)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3>(values1[index], values2[index], values3[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    this._locate(for_current.Value, out value1, out value2, out value3);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3>(values1[index], values2[index], values3[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            this._locate(removal, out axis1, out axis2, out axis3);
            this.Remove(axis1, axis2, axis3, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            this._locate(value, out axis1, out axis2, out axis3);
            return new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 4 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4>
    {
        private const int _dimensions = 4;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 4);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _medianOverride4;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride4)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride4)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride4)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride4)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride4)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> medianOverride4)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, out median_axis1, out median_axis2, out median_axis3, out median_axis4);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, count, values1, values2, values3, values4, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, out int index1, out int index2, out int index3, out int index4)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(values1[index], values2[index], values3[index], values4[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(values1[index], values2[index], values3[index], values4[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4);
            this.Remove(axis1, axis2, axis3, axis4, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            this._locate(value, out axis1, out axis2, out axis3, out axis4);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 5 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5>
    {
        private const int _dimensions = 5;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 5);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;
        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;
        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _medianOverride4;
        private Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _medianOverride5;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
            this._medianOverride5 = omnitree._medianOverride5;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride5)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(equateAxis5, "equateAxis5");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");
            Code.AssertArgNonNull(compare5, "compare5");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;
            this._medianOverride5 = medianOverride5;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride5)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4,
            medianOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride5)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride5)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride5)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> medianOverride5)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            int median_axis5;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);
            if (this._medianOverride5 != null)
                pointOfDivision5 = this._medianOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, count, values1, values2, values3, values4, values5, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, out int index1, out int index2, out int index3, out int index4, out int index5)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 5)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 1 << 5;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(values1[index], values2[index], values3[index], values4[index], values5[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                BigArray<Axis5> values5 = new BigArray<Axis5>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Theta.Algorithms.Sort<Axis5>.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis5>.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(values1[index], values2[index], values3[index], values4[index], values5[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 1 << 2)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 1 << 2;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5);
            this.Remove(axis1, axis2, axis3, axis4, axis5, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            if (bounds.Min5.Exists && bounds.Max5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater && (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            if (!this._equate5(a.Axis5, b.Axis5))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 6 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
    {
        private const int _dimensions = 6;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 6);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;
        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;
        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;
        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;
        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _medianOverride4;
        private Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _medianOverride5;
        private Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _medianOverride6;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
            this._medianOverride5 = omnitree._medianOverride5;
            this._medianOverride6 = omnitree._medianOverride6;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride6)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(equateAxis5, "equateAxis5");
            Code.AssertArgNonNull(equateAxis6, "equateAxis6");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");
            Code.AssertArgNonNull(compare5, "compare5");
            Code.AssertArgNonNull(compare6, "compare6");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;
            this._medianOverride5 = medianOverride5;
            this._medianOverride6 = medianOverride6;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride6)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4,
            medianOverride5,
            medianOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride6)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride6)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride6)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> medianOverride6)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            int median_axis5;
            int median_axis6;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);
            if (this._medianOverride5 != null)
                pointOfDivision5 = this._medianOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);
            if (this._medianOverride6 != null)
                pointOfDivision6 = this._medianOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, count, values1, values2, values3, values4, values5, values6, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 6)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 1 << 6;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 1 << 5)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 1 << 5;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                BigArray<Axis5> values5 = new BigArray<Axis5>(leaf.Count);
                BigArray<Axis6> values6 = new BigArray<Axis6>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Theta.Algorithms.Sort<Axis5>.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis5>.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Theta.Algorithms.Sort<Axis6>.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis6>.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 1 << 2)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 1 << 2;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }
            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 1 << 2)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 1 << 2;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            if (bounds.Min5.Exists && bounds.Max5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater && (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less))
                return true;
            if (bounds.Min6.Exists && bounds.Max6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater && (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;
            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;
            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;
            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            if (!this._equate5(a.Axis5, b.Axis5))
                return false;
            if (!this._equate6(a.Axis6, b.Axis6))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 7 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
    {
        private const int _dimensions = 7;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 7);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;
        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;
        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;
        private bool _defaultEquate7;
        private Equate<Axis7> _equate7;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;
        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;
        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;
        private bool _defaultCompare7;
        private Compare<Axis7> _compare7;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride4;
        private Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride5;
        private Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride6;
        private Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _medianOverride7;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultEquate7 = omnitree._defaultEquate7;
            this._equate7 = omnitree._equate7;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._defaultCompare7 = omnitree._defaultCompare7;
            this._compare7 = omnitree._compare7;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
            this._medianOverride5 = omnitree._medianOverride5;
            this._medianOverride6 = omnitree._medianOverride6;
            this._medianOverride7 = omnitree._medianOverride7;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultEquate7,
            Equate<Axis7> equateAxis7,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            bool defaultCompare7,
            Compare<Axis7> compare7,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride7)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(equateAxis5, "equateAxis5");
            Code.AssertArgNonNull(equateAxis6, "equateAxis6");
            Code.AssertArgNonNull(equateAxis7, "equateAxis7");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");
            Code.AssertArgNonNull(compare5, "compare5");
            Code.AssertArgNonNull(compare6, "compare6");
            Code.AssertArgNonNull(compare7, "compare7");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultEquate7 = defaultEquate7;
            this._equate7 = equateAxis7;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._defaultCompare7 = defaultCompare7;
            this._compare7 = compare7;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;
            this._medianOverride5 = medianOverride5;
            this._medianOverride6 = medianOverride6;
            this._medianOverride7 = medianOverride7;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride7)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            equateAxis7,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            false,
            compare7,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4,
            medianOverride5,
            medianOverride6,
            medianOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                equateAxis7,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride7)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride7)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride7)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> medianOverride7)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <param name="axis7">The coordinate along axis 7.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6, axis7); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }
        /// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
        public Compare<Axis7> Compare7 { get { return this._compare7; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }
        /// <summary>The function for equating values along the 7D axis.</summary>
        public Equate<Axis7> EquateAxis7 { get { return this._equate7; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;
            Axis7 pointOfDivision7;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            int median_axis5;
            int median_axis6;
            int median_axis7;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6, out median_axis7);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);
            if (this._medianOverride5 != null)
                pointOfDivision5 = this._medianOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);
            if (this._medianOverride6 != null)
                pointOfDivision6 = this._medianOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);
            if (this._medianOverride7 != null)
                pointOfDivision7 = this._medianOverride7(parent.Bounds, additions);
            else
                pointOfDivision7 = values7(median_axis7);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6, pointOfDivision7);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, int previous7, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6, out int index7)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                index7 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 7)
            {
                index7 = previous7 + mid_child_range;
                child_index -= 1 << 7;
            }
            else
            {
                index7 = previous7 - mid_child_range;
            }

            if (child_index >= 1 << 6)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 1 << 6;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 1 << 5)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 1 << 5;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Axis7[] values7 = new Axis7[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i], out values7[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                if (_defaultCompare7) Array.Sort(values7);
                else Array.Sort(values7, Compare.ToSystemComparison(this._compare7));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                BigArray<Axis5> values5 = new BigArray<Axis5>(leaf.Count);
                BigArray<Axis6> values6 = new BigArray<Axis6>(leaf.Count);
                BigArray<Axis7> values7 = new BigArray<Axis7>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    Axis7 value7;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6, out value7);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                    values7[i] = value7;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Theta.Algorithms.Sort<Axis5>.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis5>.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Theta.Algorithms.Sort<Axis6>.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis6>.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                if (_defaultCompare7) Theta.Algorithms.Sort<Axis7>.Merge(Compare.Default, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis7>.Merge(_compare7, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis7> min7, max7;
            if (child_index >= 1 << 2)
            {
                min7 = branch.PointOfDivision.Axis7;
                max7 = branch.Bounds.Max7;
                child_index -= 1 << 2;
            }
            else
            {
                min7 = branch.Bounds.Min7;
                max7 = branch.PointOfDivision.Axis7;
            }
            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 1 << 2)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 1 << 2;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }
            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 1 << 2)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 1 << 2;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value, bounds.Min7.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, axis7, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            if (bounds.Min5.Exists && bounds.Max5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater && (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less))
                return true;
            if (bounds.Min6.Exists && bounds.Max6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater && (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less))
                return true;
            if (bounds.Min7.Exists && bounds.Max7.Exists && this._compare7(bounds.Min7.Value, vector.Axis7) != Comparison.Greater && (this._compare7(bounds.Max7.Value, vector.Axis7) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            if (!(this._compare7(vector.Axis7, pointOfDivision.Axis7) == Comparison.Less))
                child += 1 << 6;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;
            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;
            if (a.Max7.Exists && b.Min7.Exists && this._compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && this._compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;
            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;
            if (bounds.Min7.Exists && this._compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && this._compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;
            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;
            if (b.Min7.Exists && a.Min7.Exists && this._compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && this._compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            if (!this._equate5(a.Axis5, b.Axis5))
                return false;
            if (!this._equate6(a.Axis6, b.Axis6))
                return false;
            if (!this._equate7(a.Axis7, b.Axis7))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 8 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>
    {
        private const int _dimensions = 8;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 8);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;
        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;
        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;
        private bool _defaultEquate7;
        private Equate<Axis7> _equate7;
        private bool _defaultEquate8;
        private Equate<Axis8> _equate8;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;
        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;
        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;
        private bool _defaultCompare7;
        private Compare<Axis7> _compare7;
        private bool _defaultCompare8;
        private Compare<Axis8> _compare8;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride4;
        private Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride5;
        private Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride6;
        private Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride7;
        private Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> _medianOverride8;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultEquate7 = omnitree._defaultEquate7;
            this._equate7 = omnitree._equate7;
            this._defaultEquate8 = omnitree._defaultEquate8;
            this._equate8 = omnitree._equate8;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._defaultCompare7 = omnitree._defaultCompare7;
            this._compare7 = omnitree._compare7;
            this._defaultCompare8 = omnitree._defaultCompare8;
            this._compare8 = omnitree._compare8;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
            this._medianOverride5 = omnitree._medianOverride5;
            this._medianOverride6 = omnitree._medianOverride6;
            this._medianOverride7 = omnitree._medianOverride7;
            this._medianOverride8 = omnitree._medianOverride8;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultEquate7,
            Equate<Axis7> equateAxis7,
            bool defaultEquate8,
            Equate<Axis8> equateAxis8,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            bool defaultCompare7,
            Compare<Axis7> compare7,
            bool defaultCompare8,
            Compare<Axis8> compare8,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride8)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(equateAxis5, "equateAxis5");
            Code.AssertArgNonNull(equateAxis6, "equateAxis6");
            Code.AssertArgNonNull(equateAxis7, "equateAxis7");
            Code.AssertArgNonNull(equateAxis8, "equateAxis8");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");
            Code.AssertArgNonNull(compare5, "compare5");
            Code.AssertArgNonNull(compare6, "compare6");
            Code.AssertArgNonNull(compare7, "compare7");
            Code.AssertArgNonNull(compare8, "compare8");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultEquate7 = defaultEquate7;
            this._equate7 = equateAxis7;
            this._defaultEquate8 = defaultEquate8;
            this._equate8 = equateAxis8;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._defaultCompare7 = defaultCompare7;
            this._compare7 = compare7;
            this._defaultCompare8 = defaultCompare8;
            this._compare8 = compare8;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;
            this._medianOverride5 = medianOverride5;
            this._medianOverride6 = medianOverride6;
            this._medianOverride7 = medianOverride7;
            this._medianOverride8 = medianOverride8;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Equate<Axis8> equateAxis8,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride8)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            equateAxis7,
            false,
            equateAxis8,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            false,
            compare7,
            false,
            compare8,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4,
            medianOverride5,
            medianOverride6,
            medianOverride7,
            medianOverride8)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Equate<Axis8> equateAxis8,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                equateAxis7,
                false,
                equateAxis8,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride8)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride8)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride8)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>> medianOverride8)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <param name="axis7">The coordinate along axis 7.</param>
        /// <param name="axis8">The coordinate along axis 8.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }
        /// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
        public Compare<Axis7> Compare7 { get { return this._compare7; } }
        /// <summary>The comparison function the Omnitree is using along the 8D axis.</summary>
        public Compare<Axis8> Compare8 { get { return this._compare8; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }
        /// <summary>The function for equating values along the 7D axis.</summary>
        public Equate<Axis7> EquateAxis7 { get { return this._equate7; } }
        /// <summary>The function for equating values along the 8D axis.</summary>
        public Equate<Axis8> EquateAxis8 { get { return this._equate8; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis8> values8;
                IAsyncResult result8 = null;
                if (this._medianOverride8 != null)
                    values8 = null;
                else
                {
                    values8 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values8 = new BigArray<Axis8>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values8[i] = LocateVector(additions[i]).Axis8;
                        Theta.Algorithms.Sort<Axis8>.Merge(this._compare8, (int i) => { return values8[(ulong)i]; }, (int i, Axis8 value) => { values8[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result8 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();
                if (this._medianOverride8 == null && allowMultithreading)
                    result8.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, (int index) => { return values8[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis8> values8;
                IAsyncResult result8 = null;
                if (this._medianOverride8 != null)
                    values8 = null;
                else
                {
                    values8 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values8 = new BigArray<Axis8>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values8[i] = LocateVector(additions[i]).Axis8;
                        Theta.Algorithms.Sort<Axis8>.Merge(this._compare8, (int i) => { return values8[(ulong)i]; }, (int i, Axis8 value) => { values8[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result8 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();
                if (this._medianOverride8 == null && allowMultithreading)
                    result8.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, (int index) => { return values8[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int prevmed8, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, Get<Axis8> values8, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;
            Axis7 pointOfDivision7;
            Axis8 pointOfDivision8;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            int median_axis5;
            int median_axis6;
            int median_axis7;
            int median_axis8;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, prevmed8, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6, out median_axis7, out median_axis8);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);
            if (this._medianOverride5 != null)
                pointOfDivision5 = this._medianOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);
            if (this._medianOverride6 != null)
                pointOfDivision6 = this._medianOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);
            if (this._medianOverride7 != null)
                pointOfDivision7 = this._medianOverride7(parent.Bounds, additions);
            else
                pointOfDivision7 = values7(median_axis7);
            if (this._medianOverride8 != null)
                pointOfDivision8 = this._medianOverride8(parent.Bounds, additions);
            else
                pointOfDivision8 = values8(median_axis8);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6, pointOfDivision7, pointOfDivision8);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int prevmed8, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, Get<Axis8> values8, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, prevmed8, count, values1, values2, values3, values4, values5, values6, values7, values8, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, int previous7, int previous8, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6, out int index7, out int index8)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                index7 = (count - 1) / 2;
                index8 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 8)
            {
                index8 = previous8 + mid_child_range;
                child_index -= 1 << 8;
            }
            else
            {
                index8 = previous8 - mid_child_range;
            }

            if (child_index >= 1 << 7)
            {
                index7 = previous7 + mid_child_range;
                child_index -= 1 << 7;
            }
            else
            {
                index7 = previous7 - mid_child_range;
            }

            if (child_index >= 1 << 6)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 1 << 6;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 1 << 5)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 1 << 5;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Axis7[] values7 = new Axis7[leaf.Count];
                Axis8[] values8 = new Axis8[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i], out values7[i], out values8[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                if (_defaultCompare7) Array.Sort(values7);
                else Array.Sort(values7, Compare.ToSystemComparison(this._compare7));
                if (_defaultCompare8) Array.Sort(values8);
                else Array.Sort(values8, Compare.ToSystemComparison(this._compare8));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index], values8[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                BigArray<Axis5> values5 = new BigArray<Axis5>(leaf.Count);
                BigArray<Axis6> values6 = new BigArray<Axis6>(leaf.Count);
                BigArray<Axis7> values7 = new BigArray<Axis7>(leaf.Count);
                BigArray<Axis8> values8 = new BigArray<Axis8>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    Axis7 value7;
                    Axis8 value8;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6, out value7, out value8);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                    values7[i] = value7;
                    values8[i] = value8;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Theta.Algorithms.Sort<Axis5>.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis5>.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Theta.Algorithms.Sort<Axis6>.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis6>.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                if (_defaultCompare7) Theta.Algorithms.Sort<Axis7>.Merge(Compare.Default, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis7>.Merge(_compare7, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                if (_defaultCompare8) Theta.Algorithms.Sort<Axis8>.Merge(Compare.Default, (int sorting_index) => { return values8[sorting_index]; }, (int sorting_index, Axis8 axis8) => { values8[sorting_index] = axis8; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis8>.Merge(_compare8, (int sorting_index) => { return values8[sorting_index]; }, (int sorting_index, Axis8 axis8) => { values8[sorting_index] = axis8; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index], values8[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis8> min8, max8;
            if (child_index >= 1 << 2)
            {
                min8 = branch.PointOfDivision.Axis8;
                max8 = branch.Bounds.Max8;
                child_index -= 1 << 2;
            }
            else
            {
                min8 = branch.Bounds.Min8;
                max8 = branch.PointOfDivision.Axis8;
            }
            Omnitree.Bound<Axis7> min7, max7;
            if (child_index >= 1 << 2)
            {
                min7 = branch.PointOfDivision.Axis7;
                max7 = branch.Bounds.Max7;
                child_index -= 1 << 2;
            }
            else
            {
                min7 = branch.Bounds.Min7;
                max7 = branch.PointOfDivision.Axis7;
            }
            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 1 << 2)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 1 << 2;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }
            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 1 << 2)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 1 << 2;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value, bounds.Min7.Value, bounds.Min8.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            Axis8 axis8;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7, out axis8);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            if (bounds.Min5.Exists && bounds.Max5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater && (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less))
                return true;
            if (bounds.Min6.Exists && bounds.Max6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater && (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less))
                return true;
            if (bounds.Min7.Exists && bounds.Max7.Exists && this._compare7(bounds.Min7.Value, vector.Axis7) != Comparison.Greater && (this._compare7(bounds.Max7.Value, vector.Axis7) != Comparison.Less))
                return true;
            if (bounds.Min8.Exists && bounds.Max8.Exists && this._compare8(bounds.Min8.Value, vector.Axis8) != Comparison.Greater && (this._compare8(bounds.Max8.Value, vector.Axis8) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            if (!(this._compare7(vector.Axis7, pointOfDivision.Axis7) == Comparison.Less))
                child += 1 << 6;
            if (!(this._compare8(vector.Axis8, pointOfDivision.Axis8) == Comparison.Less))
                child += 1 << 7;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;
            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;
            if (a.Max7.Exists && b.Min7.Exists && this._compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && this._compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;
            if (a.Max8.Exists && b.Min8.Exists && this._compare8(a.Max8.Value, b.Min8.Value) == Comparison.Less)
                return false;
            else if (a.Min8.Exists && b.Max8.Exists && this._compare8(a.Min8.Value, b.Max8.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;
            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;
            if (bounds.Min7.Exists && this._compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && this._compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;
            if (bounds.Min8.Exists && this._compare8(vector.Axis8, bounds.Min8.Value) == Comparison.Less)
                return false;
            else if (bounds.Max8.Exists && this._compare8(vector.Axis8, bounds.Max8.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists) || (a.Min8.Exists && !b.Min8.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;
            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;
            if (b.Min7.Exists && a.Min7.Exists && this._compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && this._compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;
            if (b.Min8.Exists && a.Min8.Exists && this._compare8(a.Min8.Value, b.Min8.Value) != Comparison.Less)
                return false;
            if (b.Max8.Exists && a.Max8.Exists && this._compare8(a.Max8.Value, b.Max8.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            if (!this._equate5(a.Axis5, b.Axis5))
                return false;
            if (!this._equate6(a.Axis6, b.Axis6))
                return false;
            if (!this._equate7(a.Axis7, b.Axis7))
                return false;
            if (!this._equate8(a.Axis8, b.Axis8))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            Axis8 axis8;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7, out axis8);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 9 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>
    {
        private const int _dimensions = 9;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 9);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;
        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;
        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;
        private bool _defaultEquate7;
        private Equate<Axis7> _equate7;
        private bool _defaultEquate8;
        private Equate<Axis8> _equate8;
        private bool _defaultEquate9;
        private Equate<Axis9> _equate9;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;
        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;
        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;
        private bool _defaultCompare7;
        private Compare<Axis7> _compare7;
        private bool _defaultCompare8;
        private Compare<Axis8> _compare8;
        private bool _defaultCompare9;
        private Compare<Axis9> _compare9;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride4;
        private Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride5;
        private Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride6;
        private Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride7;
        private Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride8;
        private Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> _medianOverride9;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultEquate7 = omnitree._defaultEquate7;
            this._equate7 = omnitree._equate7;
            this._defaultEquate8 = omnitree._defaultEquate8;
            this._equate8 = omnitree._equate8;
            this._defaultEquate9 = omnitree._defaultEquate9;
            this._equate9 = omnitree._equate9;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._defaultCompare7 = omnitree._defaultCompare7;
            this._compare7 = omnitree._compare7;
            this._defaultCompare8 = omnitree._defaultCompare8;
            this._compare8 = omnitree._compare8;
            this._defaultCompare9 = omnitree._defaultCompare9;
            this._compare9 = omnitree._compare9;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
            this._medianOverride5 = omnitree._medianOverride5;
            this._medianOverride6 = omnitree._medianOverride6;
            this._medianOverride7 = omnitree._medianOverride7;
            this._medianOverride8 = omnitree._medianOverride8;
            this._medianOverride9 = omnitree._medianOverride9;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultEquate7,
            Equate<Axis7> equateAxis7,
            bool defaultEquate8,
            Equate<Axis8> equateAxis8,
            bool defaultEquate9,
            Equate<Axis9> equateAxis9,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            bool defaultCompare7,
            Compare<Axis7> compare7,
            bool defaultCompare8,
            Compare<Axis8> compare8,
            bool defaultCompare9,
            Compare<Axis9> compare9,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride9)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(equateAxis5, "equateAxis5");
            Code.AssertArgNonNull(equateAxis6, "equateAxis6");
            Code.AssertArgNonNull(equateAxis7, "equateAxis7");
            Code.AssertArgNonNull(equateAxis8, "equateAxis8");
            Code.AssertArgNonNull(equateAxis9, "equateAxis9");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");
            Code.AssertArgNonNull(compare5, "compare5");
            Code.AssertArgNonNull(compare6, "compare6");
            Code.AssertArgNonNull(compare7, "compare7");
            Code.AssertArgNonNull(compare8, "compare8");
            Code.AssertArgNonNull(compare9, "compare9");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultEquate7 = defaultEquate7;
            this._equate7 = equateAxis7;
            this._defaultEquate8 = defaultEquate8;
            this._equate8 = equateAxis8;
            this._defaultEquate9 = defaultEquate9;
            this._equate9 = equateAxis9;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._defaultCompare7 = defaultCompare7;
            this._compare7 = compare7;
            this._defaultCompare8 = defaultCompare8;
            this._compare8 = compare8;
            this._defaultCompare9 = defaultCompare9;
            this._compare9 = compare9;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;
            this._medianOverride5 = medianOverride5;
            this._medianOverride6 = medianOverride6;
            this._medianOverride7 = medianOverride7;
            this._medianOverride8 = medianOverride8;
            this._medianOverride9 = medianOverride9;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Equate<Axis8> equateAxis8,
            Equate<Axis9> equateAxis9,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride9)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            equateAxis7,
            false,
            equateAxis8,
            false,
            equateAxis9,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            false,
            compare7,
            false,
            compare8,
            false,
            compare9,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4,
            medianOverride5,
            medianOverride6,
            medianOverride7,
            medianOverride8,
            medianOverride9)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Equate<Axis8> equateAxis8,
            Equate<Axis9> equateAxis9,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                equateAxis7,
                false,
                equateAxis8,
                false,
                equateAxis9,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride9)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride9)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride9)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>> medianOverride9)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <param name="axis7">The coordinate along axis 7.</param>
        /// <param name="axis8">The coordinate along axis 8.</param>
        /// <param name="axis9">The coordinate along axis 9.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }
        /// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
        public Compare<Axis7> Compare7 { get { return this._compare7; } }
        /// <summary>The comparison function the Omnitree is using along the 8D axis.</summary>
        public Compare<Axis8> Compare8 { get { return this._compare8; } }
        /// <summary>The comparison function the Omnitree is using along the 9D axis.</summary>
        public Compare<Axis9> Compare9 { get { return this._compare9; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }
        /// <summary>The function for equating values along the 7D axis.</summary>
        public Equate<Axis7> EquateAxis7 { get { return this._equate7; } }
        /// <summary>The function for equating values along the 8D axis.</summary>
        public Equate<Axis8> EquateAxis8 { get { return this._equate8; } }
        /// <summary>The function for equating values along the 9D axis.</summary>
        public Equate<Axis9> EquateAxis9 { get { return this._equate9; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis8> values8;
                IAsyncResult result8 = null;
                if (this._medianOverride8 != null)
                    values8 = null;
                else
                {
                    values8 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values8 = new BigArray<Axis8>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values8[i] = LocateVector(additions[i]).Axis8;
                        Theta.Algorithms.Sort<Axis8>.Merge(this._compare8, (int i) => { return values8[(ulong)i]; }, (int i, Axis8 value) => { values8[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result8 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis9> values9;
                IAsyncResult result9 = null;
                if (this._medianOverride9 != null)
                    values9 = null;
                else
                {
                    values9 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values9 = new BigArray<Axis9>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values9[i] = LocateVector(additions[i]).Axis9;
                        Theta.Algorithms.Sort<Axis9>.Merge(this._compare9, (int i) => { return values9[(ulong)i]; }, (int i, Axis9 value) => { values9[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result9 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();
                if (this._medianOverride8 == null && allowMultithreading)
                    result8.AsyncWaitHandle.WaitOne();
                if (this._medianOverride9 == null && allowMultithreading)
                    result9.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, (int index) => { return values8[index]; }, (int index) => { return values9[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis8> values8;
                IAsyncResult result8 = null;
                if (this._medianOverride8 != null)
                    values8 = null;
                else
                {
                    values8 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values8 = new BigArray<Axis8>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values8[i] = LocateVector(additions[i]).Axis8;
                        Theta.Algorithms.Sort<Axis8>.Merge(this._compare8, (int i) => { return values8[(ulong)i]; }, (int i, Axis8 value) => { values8[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result8 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis9> values9;
                IAsyncResult result9 = null;
                if (this._medianOverride9 != null)
                    values9 = null;
                else
                {
                    values9 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values9 = new BigArray<Axis9>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values9[i] = LocateVector(additions[i]).Axis9;
                        Theta.Algorithms.Sort<Axis9>.Merge(this._compare9, (int i) => { return values9[(ulong)i]; }, (int i, Axis9 value) => { values9[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result9 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();
                if (this._medianOverride8 == null && allowMultithreading)
                    result8.AsyncWaitHandle.WaitOne();
                if (this._medianOverride9 == null && allowMultithreading)
                    result9.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, (int index) => { return values8[index]; }, (int index) => { return values9[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int prevmed8, int prevmed9, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, Get<Axis8> values8, Get<Axis9> values9, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;
            Axis7 pointOfDivision7;
            Axis8 pointOfDivision8;
            Axis9 pointOfDivision9;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            int median_axis5;
            int median_axis6;
            int median_axis7;
            int median_axis8;
            int median_axis9;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, prevmed8, prevmed9, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6, out median_axis7, out median_axis8, out median_axis9);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);
            if (this._medianOverride5 != null)
                pointOfDivision5 = this._medianOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);
            if (this._medianOverride6 != null)
                pointOfDivision6 = this._medianOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);
            if (this._medianOverride7 != null)
                pointOfDivision7 = this._medianOverride7(parent.Bounds, additions);
            else
                pointOfDivision7 = values7(median_axis7);
            if (this._medianOverride8 != null)
                pointOfDivision8 = this._medianOverride8(parent.Bounds, additions);
            else
                pointOfDivision8 = values8(median_axis8);
            if (this._medianOverride9 != null)
                pointOfDivision9 = this._medianOverride9(parent.Bounds, additions);
            else
                pointOfDivision9 = values9(median_axis9);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6, pointOfDivision7, pointOfDivision8, pointOfDivision9);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int prevmed8, int prevmed9, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, Get<Axis8> values8, Get<Axis9> values9, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, prevmed8, prevmed9, count, values1, values2, values3, values4, values5, values6, values7, values8, values9, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, int previous7, int previous8, int previous9, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6, out int index7, out int index8, out int index9)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                index7 = (count - 1) / 2;
                index8 = (count - 1) / 2;
                index9 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 9)
            {
                index9 = previous9 + mid_child_range;
                child_index -= 1 << 9;
            }
            else
            {
                index9 = previous9 - mid_child_range;
            }

            if (child_index >= 1 << 8)
            {
                index8 = previous8 + mid_child_range;
                child_index -= 1 << 8;
            }
            else
            {
                index8 = previous8 - mid_child_range;
            }

            if (child_index >= 1 << 7)
            {
                index7 = previous7 + mid_child_range;
                child_index -= 1 << 7;
            }
            else
            {
                index7 = previous7 - mid_child_range;
            }

            if (child_index >= 1 << 6)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 1 << 6;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 1 << 5)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 1 << 5;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Axis7[] values7 = new Axis7[leaf.Count];
                Axis8[] values8 = new Axis8[leaf.Count];
                Axis9[] values9 = new Axis9[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i], out values7[i], out values8[i], out values9[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                if (_defaultCompare7) Array.Sort(values7);
                else Array.Sort(values7, Compare.ToSystemComparison(this._compare7));
                if (_defaultCompare8) Array.Sort(values8);
                else Array.Sort(values8, Compare.ToSystemComparison(this._compare8));
                if (_defaultCompare9) Array.Sort(values9);
                else Array.Sort(values9, Compare.ToSystemComparison(this._compare9));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index], values8[index], values9[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                BigArray<Axis5> values5 = new BigArray<Axis5>(leaf.Count);
                BigArray<Axis6> values6 = new BigArray<Axis6>(leaf.Count);
                BigArray<Axis7> values7 = new BigArray<Axis7>(leaf.Count);
                BigArray<Axis8> values8 = new BigArray<Axis8>(leaf.Count);
                BigArray<Axis9> values9 = new BigArray<Axis9>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    Axis7 value7;
                    Axis8 value8;
                    Axis9 value9;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6, out value7, out value8, out value9);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                    values7[i] = value7;
                    values8[i] = value8;
                    values9[i] = value9;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Theta.Algorithms.Sort<Axis5>.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis5>.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Theta.Algorithms.Sort<Axis6>.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis6>.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                if (_defaultCompare7) Theta.Algorithms.Sort<Axis7>.Merge(Compare.Default, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis7>.Merge(_compare7, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                if (_defaultCompare8) Theta.Algorithms.Sort<Axis8>.Merge(Compare.Default, (int sorting_index) => { return values8[sorting_index]; }, (int sorting_index, Axis8 axis8) => { values8[sorting_index] = axis8; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis8>.Merge(_compare8, (int sorting_index) => { return values8[sorting_index]; }, (int sorting_index, Axis8 axis8) => { values8[sorting_index] = axis8; }, 0, (int)values1.Length);
                if (_defaultCompare9) Theta.Algorithms.Sort<Axis9>.Merge(Compare.Default, (int sorting_index) => { return values9[sorting_index]; }, (int sorting_index, Axis9 axis9) => { values9[sorting_index] = axis9; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis9>.Merge(_compare9, (int sorting_index) => { return values9[sorting_index]; }, (int sorting_index, Axis9 axis9) => { values9[sorting_index] = axis9; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index], values8[index], values9[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis9> min9, max9;
            if (child_index >= 1 << 2)
            {
                min9 = branch.PointOfDivision.Axis9;
                max9 = branch.Bounds.Max9;
                child_index -= 1 << 2;
            }
            else
            {
                min9 = branch.Bounds.Min9;
                max9 = branch.PointOfDivision.Axis9;
            }
            Omnitree.Bound<Axis8> min8, max8;
            if (child_index >= 1 << 2)
            {
                min8 = branch.PointOfDivision.Axis8;
                max8 = branch.Bounds.Max8;
                child_index -= 1 << 2;
            }
            else
            {
                min8 = branch.Bounds.Min8;
                max8 = branch.PointOfDivision.Axis8;
            }
            Omnitree.Bound<Axis7> min7, max7;
            if (child_index >= 1 << 2)
            {
                min7 = branch.PointOfDivision.Axis7;
                max7 = branch.Bounds.Max7;
                child_index -= 1 << 2;
            }
            else
            {
                min7 = branch.Bounds.Min7;
                max7 = branch.PointOfDivision.Axis7;
            }
            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 1 << 2)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 1 << 2;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }
            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 1 << 2)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 1 << 2;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value, bounds.Min7.Value, bounds.Min8.Value, bounds.Min9.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            Axis8 axis8;
            Axis9 axis9;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7, out axis8, out axis9);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            if (bounds.Min5.Exists && bounds.Max5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater && (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less))
                return true;
            if (bounds.Min6.Exists && bounds.Max6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater && (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less))
                return true;
            if (bounds.Min7.Exists && bounds.Max7.Exists && this._compare7(bounds.Min7.Value, vector.Axis7) != Comparison.Greater && (this._compare7(bounds.Max7.Value, vector.Axis7) != Comparison.Less))
                return true;
            if (bounds.Min8.Exists && bounds.Max8.Exists && this._compare8(bounds.Min8.Value, vector.Axis8) != Comparison.Greater && (this._compare8(bounds.Max8.Value, vector.Axis8) != Comparison.Less))
                return true;
            if (bounds.Min9.Exists && bounds.Max9.Exists && this._compare9(bounds.Min9.Value, vector.Axis9) != Comparison.Greater && (this._compare9(bounds.Max9.Value, vector.Axis9) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            if (!(this._compare7(vector.Axis7, pointOfDivision.Axis7) == Comparison.Less))
                child += 1 << 6;
            if (!(this._compare8(vector.Axis8, pointOfDivision.Axis8) == Comparison.Less))
                child += 1 << 7;
            if (!(this._compare9(vector.Axis9, pointOfDivision.Axis9) == Comparison.Less))
                child += 1 << 8;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;
            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;
            if (a.Max7.Exists && b.Min7.Exists && this._compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && this._compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;
            if (a.Max8.Exists && b.Min8.Exists && this._compare8(a.Max8.Value, b.Min8.Value) == Comparison.Less)
                return false;
            else if (a.Min8.Exists && b.Max8.Exists && this._compare8(a.Min8.Value, b.Max8.Value) == Comparison.Greater)
                return false;
            if (a.Max9.Exists && b.Min9.Exists && this._compare9(a.Max9.Value, b.Min9.Value) == Comparison.Less)
                return false;
            else if (a.Min9.Exists && b.Max9.Exists && this._compare9(a.Min9.Value, b.Max9.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;
            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;
            if (bounds.Min7.Exists && this._compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && this._compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;
            if (bounds.Min8.Exists && this._compare8(vector.Axis8, bounds.Min8.Value) == Comparison.Less)
                return false;
            else if (bounds.Max8.Exists && this._compare8(vector.Axis8, bounds.Max8.Value) == Comparison.Greater)
                return false;
            if (bounds.Min9.Exists && this._compare9(vector.Axis9, bounds.Min9.Value) == Comparison.Less)
                return false;
            else if (bounds.Max9.Exists && this._compare9(vector.Axis9, bounds.Max9.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists) || (a.Min8.Exists && !b.Min8.Exists) || (a.Min9.Exists && !b.Min9.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;
            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;
            if (b.Min7.Exists && a.Min7.Exists && this._compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && this._compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;
            if (b.Min8.Exists && a.Min8.Exists && this._compare8(a.Min8.Value, b.Min8.Value) != Comparison.Less)
                return false;
            if (b.Max8.Exists && a.Max8.Exists && this._compare8(a.Max8.Value, b.Max8.Value) != Comparison.Greater)
                return false;
            if (b.Min9.Exists && a.Min9.Exists && this._compare9(a.Min9.Value, b.Min9.Value) != Comparison.Less)
                return false;
            if (b.Max9.Exists && a.Max9.Exists && this._compare9(a.Max9.Value, b.Max9.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            if (!this._equate5(a.Axis5, b.Axis5))
                return false;
            if (!this._equate6(a.Axis6, b.Axis6))
                return false;
            if (!this._equate7(a.Axis7, b.Axis7))
                return false;
            if (!this._equate8(a.Axis8, b.Axis8))
                return false;
            if (!this._equate9(a.Axis9, b.Axis9))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            Axis8 axis8;
            Axis9 axis9;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7, out axis8, out axis9);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 10 Dimensional

    public interface OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> : Structure<T>,
            Structure.Countable<T>,
            Structure.Addable<T>,
            Structure.Clearable<T>,
            Structure.Removable<T>,
            Structure.Equating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        void Stepper(Step<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> : OmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>
    {
        private const int _dimensions = 10;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 10);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;
        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;
        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;
        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;
        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;
        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;
        private bool _defaultEquate7;
        private Equate<Axis7> _equate7;
        private bool _defaultEquate8;
        private Equate<Axis8> _equate8;
        private bool _defaultEquate9;
        private Equate<Axis9> _equate9;
        private bool _defaultEquate10;
        private Equate<Axis10> _equate10;

        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;
        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;
        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;
        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;
        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;
        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;
        private bool _defaultCompare7;
        private Compare<Axis7> _compare7;
        private bool _defaultCompare8;
        private Compare<Axis8> _compare8;
        private bool _defaultCompare9;
        private Compare<Axis9> _compare9;
        private bool _defaultCompare10;
        private Compare<Axis10> _compare10;

        // allows median overriding for custom optimizations
        private Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride1;
        private Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride2;
        private Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride3;
        private Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride4;
        private Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride5;
        private Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride6;
        private Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride7;
        private Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride8;
        private Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride9;
        private Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> _medianOverride10;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultEquate7 = omnitree._defaultEquate7;
            this._equate7 = omnitree._equate7;
            this._defaultEquate8 = omnitree._defaultEquate8;
            this._equate8 = omnitree._equate8;
            this._defaultEquate9 = omnitree._defaultEquate9;
            this._equate9 = omnitree._equate9;
            this._defaultEquate10 = omnitree._defaultEquate10;
            this._equate10 = omnitree._equate10;
            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._defaultCompare7 = omnitree._defaultCompare7;
            this._compare7 = omnitree._compare7;
            this._defaultCompare8 = omnitree._defaultCompare8;
            this._compare8 = omnitree._compare8;
            this._defaultCompare9 = omnitree._defaultCompare9;
            this._compare9 = omnitree._compare9;
            this._defaultCompare10 = omnitree._defaultCompare10;
            this._compare10 = omnitree._compare10;
            this._medianOverride1 = omnitree._medianOverride1;
            this._medianOverride2 = omnitree._medianOverride2;
            this._medianOverride3 = omnitree._medianOverride3;
            this._medianOverride4 = omnitree._medianOverride4;
            this._medianOverride5 = omnitree._medianOverride5;
            this._medianOverride6 = omnitree._medianOverride6;
            this._medianOverride7 = omnitree._medianOverride7;
            this._medianOverride8 = omnitree._medianOverride8;
            this._medianOverride9 = omnitree._medianOverride9;
            this._medianOverride10 = omnitree._medianOverride10;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            bool defaultEquate,
            Equate<T> equate,
            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultEquate7,
            Equate<Axis7> equateAxis7,
            bool defaultEquate8,
            Equate<Axis8> equateAxis8,
            bool defaultEquate9,
            Equate<Axis9> equateAxis9,
            bool defaultEquate10,
            Equate<Axis10> equateAxis10,
            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            bool defaultCompare7,
            Compare<Axis7> compare7,
            bool defaultCompare8,
            Compare<Axis8> compare8,
            bool defaultCompare9,
            Compare<Axis9> compare9,
            bool defaultCompare10,
            Compare<Axis10> compare10,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride9,
            Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride10)
        {
            Code.AssertArgNonNull(locate, "locate");
            Code.AssertArgNonNull(equate, "equate");
            Code.AssertArgNonNull(equateAxis1, "equateAxis1");
            Code.AssertArgNonNull(equateAxis2, "equateAxis2");
            Code.AssertArgNonNull(equateAxis3, "equateAxis3");
            Code.AssertArgNonNull(equateAxis4, "equateAxis4");
            Code.AssertArgNonNull(equateAxis5, "equateAxis5");
            Code.AssertArgNonNull(equateAxis6, "equateAxis6");
            Code.AssertArgNonNull(equateAxis7, "equateAxis7");
            Code.AssertArgNonNull(equateAxis8, "equateAxis8");
            Code.AssertArgNonNull(equateAxis9, "equateAxis9");
            Code.AssertArgNonNull(equateAxis10, "equateAxis10");
            Code.AssertArgNonNull(compare1, "compare1");
            Code.AssertArgNonNull(compare2, "compare2");
            Code.AssertArgNonNull(compare3, "compare3");
            Code.AssertArgNonNull(compare4, "compare4");
            Code.AssertArgNonNull(compare5, "compare5");
            Code.AssertArgNonNull(compare6, "compare6");
            Code.AssertArgNonNull(compare7, "compare7");
            Code.AssertArgNonNull(compare8, "compare8");
            Code.AssertArgNonNull(compare9, "compare9");
            Code.AssertArgNonNull(compare10, "compare10");

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultEquate7 = defaultEquate7;
            this._equate7 = equateAxis7;
            this._defaultEquate8 = defaultEquate8;
            this._equate8 = equateAxis8;
            this._defaultEquate9 = defaultEquate9;
            this._equate9 = equateAxis9;
            this._defaultEquate10 = defaultEquate10;
            this._equate10 = equateAxis10;
            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._defaultCompare7 = defaultCompare7;
            this._compare7 = compare7;
            this._defaultCompare8 = defaultCompare8;
            this._compare8 = compare8;
            this._defaultCompare9 = defaultCompare9;
            this._compare9 = compare9;
            this._defaultCompare10 = defaultCompare10;
            this._compare10 = compare10;
            this._medianOverride1 = medianOverride1;
            this._medianOverride2 = medianOverride2;
            this._medianOverride3 = medianOverride3;
            this._medianOverride4 = medianOverride4;
            this._medianOverride5 = medianOverride5;
            this._medianOverride6 = medianOverride6;
            this._medianOverride7 = medianOverride7;
            this._medianOverride8 = medianOverride8;
            this._medianOverride9 = medianOverride9;
            this._medianOverride10 = medianOverride10;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Equate<Axis8> equateAxis8,
            Equate<Axis9> equateAxis9,
            Equate<Axis10> equateAxis10,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Compare<Axis10> compare10,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride9,
            Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride10)
            : this(
            locate,
            false,
            equate,
            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            equateAxis7,
            false,
            equateAxis8,
            false,
            equateAxis9,
            false,
            equateAxis10,
            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            false,
            compare7,
            false,
            compare8,
            false,
            compare9,
            false,
            compare10,
            medianOverride1,
            medianOverride2,
            medianOverride3,
            medianOverride4,
            medianOverride5,
            medianOverride6,
            medianOverride7,
            medianOverride8,
            medianOverride9,
            medianOverride10)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Equate<T> equate,
            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,
            Equate<Axis8> equateAxis8,
            Equate<Axis9> equateAxis9,
            Equate<Axis10> equateAxis10,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Compare<Axis10> compare10)
            : this(
                locate,
                false,
                equate,
                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                equateAxis7,
                false,
                equateAxis8,
                false,
                equateAxis9,
                false,
                equateAxis10,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                false,
                compare10,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Compare<Axis10> compare10)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                false,
                compare10,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Equate<T> equate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Compare<Axis10> compare10,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride9,
            Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride10)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                false,
                compare10,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9,
                medianOverride10)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Compare<Axis10> compare10)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                false,
                compare10,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,
            Compare<Axis8> compare8,
            Compare<Axis9> compare9,
            Compare<Axis10> compare10,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride9,
            Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride10)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,
                false,
                compare8,
                false,
                compare9,
                false,
                compare10,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9,
                medianOverride10)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Equate<T> equate)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Equate<T> equate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride9,
            Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride10)
            : this(
                locate,
                false,
                equate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9,
                medianOverride10)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> locate,
            Omnitree.MedianOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride1,
            Omnitree.MedianOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride2,
            Omnitree.MedianOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride3,
            Omnitree.MedianOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride4,
            Omnitree.MedianOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride5,
            Omnitree.MedianOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride6,
            Omnitree.MedianOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride7,
            Omnitree.MedianOverride<T, Axis8, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride8,
            Omnitree.MedianOverride<T, Axis9, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride9,
            Omnitree.MedianOverride<T, Axis10, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>> medianOverride10)
            : this(
                locate,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Theta.Equate.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                medianOverride1,
                medianOverride2,
                medianOverride3,
                medianOverride4,
                medianOverride5,
                medianOverride6,
                medianOverride7,
                medianOverride8,
                medianOverride9,
                medianOverride10)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <param name="axis7">The coordinate along axis 7.</param>
        /// <param name="axis8">The coordinate along axis 8.</param>
        /// <param name="axis9">The coordinate along axis 9.</param>
        /// <param name="axis10">The coordinate along axis 10.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> Locate { get { return this._locate; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }
        /// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
        public Compare<Axis7> Compare7 { get { return this._compare7; } }
        /// <summary>The comparison function the Omnitree is using along the 8D axis.</summary>
        public Compare<Axis8> Compare8 { get { return this._compare8; } }
        /// <summary>The comparison function the Omnitree is using along the 9D axis.</summary>
        public Compare<Axis9> Compare9 { get { return this._compare9; } }
        /// <summary>The comparison function the Omnitree is using along the 10D axis.</summary>
        public Compare<Axis10> Compare10 { get { return this._compare10; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }
        /// <summary>The function for equating values along the 7D axis.</summary>
        public Equate<Axis7> EquateAxis7 { get { return this._equate7; } }
        /// <summary>The function for equating values along the 8D axis.</summary>
        public Equate<Axis8> EquateAxis8 { get { return this._equate8; } }
        /// <summary>The function for equating values along the 9D axis.</summary>
        public Equate<Axis9> EquateAxis9 { get { return this._equate9; } }
        /// <summary>The function for equating values along the 10D axis.</summary>
        public Equate<Axis10> EquateAxis10 { get { return this._equate10; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(BigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis8> values8;
                IAsyncResult result8 = null;
                if (this._medianOverride8 != null)
                    values8 = null;
                else
                {
                    values8 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values8 = new BigArray<Axis8>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values8[i] = LocateVector(additions[i]).Axis8;
                        Theta.Algorithms.Sort<Axis8>.Merge(this._compare8, (int i) => { return values8[(ulong)i]; }, (int i, Axis8 value) => { values8[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result8 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis9> values9;
                IAsyncResult result9 = null;
                if (this._medianOverride9 != null)
                    values9 = null;
                else
                {
                    values9 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values9 = new BigArray<Axis9>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values9[i] = LocateVector(additions[i]).Axis9;
                        Theta.Algorithms.Sort<Axis9>.Merge(this._compare9, (int i) => { return values9[(ulong)i]; }, (int i, Axis9 value) => { values9[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result9 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis10> values10;
                IAsyncResult result10 = null;
                if (this._medianOverride10 != null)
                    values10 = null;
                else
                {
                    values10 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values10 = new BigArray<Axis10>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values10[i] = LocateVector(additions[i]).Axis10;
                        Theta.Algorithms.Sort<Axis10>.Merge(this._compare10, (int i) => { return values10[(ulong)i]; }, (int i, Axis10 value) => { values10[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result10 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();
                if (this._medianOverride8 == null && allowMultithreading)
                    result8.AsyncWaitHandle.WaitOne();
                if (this._medianOverride9 == null && allowMultithreading)
                    result9.AsyncWaitHandle.WaitOne();
                if (this._medianOverride10 == null && allowMultithreading)
                    result10.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, (int index) => { return values8[index]; }, (int index) => { return values9[index]; }, (int index) => { return values10[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, null, -1);
                new_top.Count = (int)additions.Length;

                // prepare data for median computations
                BigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._medianOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new BigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Theta.Algorithms.Sort<Axis1>.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._medianOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new BigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Theta.Algorithms.Sort<Axis2>.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._medianOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new BigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Theta.Algorithms.Sort<Axis3>.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._medianOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new BigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Theta.Algorithms.Sort<Axis4>.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._medianOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new BigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Theta.Algorithms.Sort<Axis5>.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._medianOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new BigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Theta.Algorithms.Sort<Axis6>.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._medianOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new BigArray<Axis7>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Theta.Algorithms.Sort<Axis7>.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis8> values8;
                IAsyncResult result8 = null;
                if (this._medianOverride8 != null)
                    values8 = null;
                else
                {
                    values8 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values8 = new BigArray<Axis8>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values8[i] = LocateVector(additions[i]).Axis8;
                        Theta.Algorithms.Sort<Axis8>.Merge(this._compare8, (int i) => { return values8[(ulong)i]; }, (int i, Axis8 value) => { values8[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result8 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis9> values9;
                IAsyncResult result9 = null;
                if (this._medianOverride9 != null)
                    values9 = null;
                else
                {
                    values9 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values9 = new BigArray<Axis9>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values9[i] = LocateVector(additions[i]).Axis9;
                        Theta.Algorithms.Sort<Axis9>.Merge(this._compare9, (int i) => { return values9[(ulong)i]; }, (int i, Axis9 value) => { values9[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result9 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
                // prepare data for median computations
                BigArray<Axis10> values10;
                IAsyncResult result10 = null;
                if (this._medianOverride10 != null)
                    values10 = null;
                else
                {
                    values10 = null;
                    Theta.Parallels.Parallel.Operation operation = () =>
                    {
                        values10 = new BigArray<Axis10>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values10[i] = LocateVector(additions[i]).Axis10;
                        Theta.Algorithms.Sort<Axis10>.Merge(this._compare10, (int i) => { return values10[(ulong)i]; }, (int i, Axis10 value) => { values10[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result10 = Theta.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                if (this._medianOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();
                if (this._medianOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();
                if (this._medianOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();
                if (this._medianOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();
                if (this._medianOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();
                if (this._medianOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();
                if (this._medianOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();
                if (this._medianOverride8 == null && allowMultithreading)
                    result8.AsyncWaitHandle.WaitOne();
                if (this._medianOverride9 == null && allowMultithreading)
                    result9.AsyncWaitHandle.WaitOne();
                if (this._medianOverride10 == null && allowMultithreading)
                    result10.AsyncWaitHandle.WaitOne();

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, (int index) => { return values8[index]; }, (int index) => { return values9[index]; }, (int index) => { return values10[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int prevmed8, int prevmed9, int prevmed10, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, Get<Axis8> values8, Get<Axis9> values9, Get<Axis10> values10, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;
            Axis7 pointOfDivision7;
            Axis8 pointOfDivision8;
            Axis9 pointOfDivision9;
            Axis10 pointOfDivision10;

            int median_axis1;
            int median_axis2;
            int median_axis3;
            int median_axis4;
            int median_axis5;
            int median_axis6;
            int median_axis7;
            int median_axis8;
            int median_axis9;
            int median_axis10;
            GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, prevmed8, prevmed9, prevmed10, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6, out median_axis7, out median_axis8, out median_axis9, out median_axis10);

            if (this._medianOverride1 != null)
                pointOfDivision1 = this._medianOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);
            if (this._medianOverride2 != null)
                pointOfDivision2 = this._medianOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);
            if (this._medianOverride3 != null)
                pointOfDivision3 = this._medianOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);
            if (this._medianOverride4 != null)
                pointOfDivision4 = this._medianOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);
            if (this._medianOverride5 != null)
                pointOfDivision5 = this._medianOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);
            if (this._medianOverride6 != null)
                pointOfDivision6 = this._medianOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);
            if (this._medianOverride7 != null)
                pointOfDivision7 = this._medianOverride7(parent.Bounds, additions);
            else
                pointOfDivision7 = values7(median_axis7);
            if (this._medianOverride8 != null)
                pointOfDivision8 = this._medianOverride8(parent.Bounds, additions);
            else
                pointOfDivision8 = values8(median_axis8);
            if (this._medianOverride9 != null)
                pointOfDivision9 = this._medianOverride9(parent.Bounds, additions);
            else
                pointOfDivision9 = values9(median_axis9);
            if (this._medianOverride10 != null)
                pointOfDivision10 = this._medianOverride10(parent.Bounds, additions);
            else
                pointOfDivision10 = values10(median_axis10);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6, pointOfDivision7, pointOfDivision8, pointOfDivision9, pointOfDivision10);

			//			// divide the values along the medians
            //System.Collections.Generic.Dictionary<int, List<T>> collection_map = new System.Collections.Generic.Dictionary<int, List<T>>();
            //additions((T value) => 
            //{
            //    int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
            //    List<T> list = null;
            //    if (collection_map.TryGetValue(index, out list))
            //    {
            //        list.Add(value);
            //    }
            //    else
            //    {
            //        if (parent_count < 100000)
            //            list = new ListArray<T>();
            //        else
            //            list = new ListLinked<T>();
            //        collection_map.Add(index, list);
            //        list.Add(value);
            //    }
            //});
			//			
            //if (depth == 1 && allowMultithreading)
            //{
            //    // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
			//					foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//					{
			//						parent[pair.Key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, parent, pair.Key);
			//					}
            //
            //    IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
            //    for (int i = 0; i < handles.Length; i++)
            //    {
			//						throw new System.NotImplementedException();
            //        //int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
            //        //handles[i] = Theta.Parallels.Parallel.Thread(() =>
            //        //{
            //        //    Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
            //        //    (Link<List<T>, int> link) =>
            //        //        {
            //        //            ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, median_axis10, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, values10, allowMultithreading);
            //        //        });
            //        //});
            //    }
			//			
            //    foreach (IAsyncResult handle in handles)
            //    {
            //        handle.AsyncWaitHandle.WaitOne();
            //    }
            //}
            //else
            //{
			//				foreach (System.Collections.Generic.KeyValuePair<int, List<T>> pair in collection_map)
			//				{
			//					ReversedChildBuilding(parent, pair.Key, depth, pair.Value.Stepper, pair.Value.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, median_axis10, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, values10, allowMultithreading);
			//				}
            //}


            // divide the values along the medians
            Map<List<T>, int> collection_map = new MapHashLinked<List<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                List<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new ListArray<T>();
                    else
                        list = new ListLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, parent, key); });
				//
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Theta.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<List<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<List<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, median_axis10, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, values10, allowMultithreading);
                            });
                    });
                }
				
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<List<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, median_axis8, median_axis9, median_axis10, initial_count, values1, values2, values3, values4, values5, values6, values7, values8, values9, values10, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int prevmed8, int prevmed9, int prevmed10, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, Get<Axis8> values8, Get<Axis9> values9, Get<Axis10> values10, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, prevmed8, prevmed9, prevmed10, count, values1, values2, values3, values4, values5, values6, values7, values8, values9, values10, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, int previous7, int previous8, int previous9, int previous10, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6, out int index7, out int index8, out int index9, out int index10)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                index7 = (count - 1) / 2;
                index8 = (count - 1) / 2;
                index9 = (count - 1) / 2;
                index10 = (count - 1) / 2;
                return;
            }

            int splits = Compute<int>.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1 << 10)
            {
                index10 = previous10 + mid_child_range;
                child_index -= 1 << 10;
            }
            else
            {
                index10 = previous10 - mid_child_range;
            }

            if (child_index >= 1 << 9)
            {
                index9 = previous9 + mid_child_range;
                child_index -= 1 << 9;
            }
            else
            {
                index9 = previous9 - mid_child_range;
            }

            if (child_index >= 1 << 8)
            {
                index8 = previous8 + mid_child_range;
                child_index -= 1 << 8;
            }
            else
            {
                index8 = previous8 - mid_child_range;
            }

            if (child_index >= 1 << 7)
            {
                index7 = previous7 + mid_child_range;
                child_index -= 1 << 7;
            }
            else
            {
                index7 = previous7 - mid_child_range;
            }

            if (child_index >= 1 << 6)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 1 << 6;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 1 << 5)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 1 << 5;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 1 << 4)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 1 << 4;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 1 << 3)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 1 << 3;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 1 << 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 1 << 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1 << 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1 << 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Axis7[] values7 = new Axis7[leaf.Count];
                Axis8[] values8 = new Axis8[leaf.Count];
                Axis9[] values9 = new Axis9[leaf.Count];
                Axis10[] values10 = new Axis10[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i], out values7[i], out values8[i], out values9[i], out values10[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                if (_defaultCompare7) Array.Sort(values7);
                else Array.Sort(values7, Compare.ToSystemComparison(this._compare7));
                if (_defaultCompare8) Array.Sort(values8);
                else Array.Sort(values8, Compare.ToSystemComparison(this._compare8));
                if (_defaultCompare9) Array.Sort(values9);
                else Array.Sort(values9, Compare.ToSystemComparison(this._compare9));
                if (_defaultCompare10) Array.Sort(values10);
                else Array.Sort(values10, Compare.ToSystemComparison(this._compare10));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index], values8[index], values9[index], values10[index]);
            }
            catch
            {
                // extract the values
                BigArray<Axis1> values1 = new BigArray<Axis1>(leaf.Count);
                BigArray<Axis2> values2 = new BigArray<Axis2>(leaf.Count);
                BigArray<Axis3> values3 = new BigArray<Axis3>(leaf.Count);
                BigArray<Axis4> values4 = new BigArray<Axis4>(leaf.Count);
                BigArray<Axis5> values5 = new BigArray<Axis5>(leaf.Count);
                BigArray<Axis6> values6 = new BigArray<Axis6>(leaf.Count);
                BigArray<Axis7> values7 = new BigArray<Axis7>(leaf.Count);
                BigArray<Axis8> values8 = new BigArray<Axis8>(leaf.Count);
                BigArray<Axis9> values9 = new BigArray<Axis9>(leaf.Count);
                BigArray<Axis10> values10 = new BigArray<Axis10>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    Axis7 value7;
                    Axis8 value8;
                    Axis9 value9;
                    Axis10 value10;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6, out value7, out value8, out value9, out value10);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                    values7[i] = value7;
                    values8[i] = value8;
                    values9[i] = value9;
                    values10[i] = value10;
                }
                // sort the values
                if (_defaultCompare1) Theta.Algorithms.Sort<Axis1>.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis1>.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Theta.Algorithms.Sort<Axis2>.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis2>.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Theta.Algorithms.Sort<Axis3>.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis3>.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Theta.Algorithms.Sort<Axis4>.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis4>.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Theta.Algorithms.Sort<Axis5>.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis5>.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Theta.Algorithms.Sort<Axis6>.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis6>.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                if (_defaultCompare7) Theta.Algorithms.Sort<Axis7>.Merge(Compare.Default, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis7>.Merge(_compare7, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                if (_defaultCompare8) Theta.Algorithms.Sort<Axis8>.Merge(Compare.Default, (int sorting_index) => { return values8[sorting_index]; }, (int sorting_index, Axis8 axis8) => { values8[sorting_index] = axis8; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis8>.Merge(_compare8, (int sorting_index) => { return values8[sorting_index]; }, (int sorting_index, Axis8 axis8) => { values8[sorting_index] = axis8; }, 0, (int)values1.Length);
                if (_defaultCompare9) Theta.Algorithms.Sort<Axis9>.Merge(Compare.Default, (int sorting_index) => { return values9[sorting_index]; }, (int sorting_index, Axis9 axis9) => { values9[sorting_index] = axis9; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis9>.Merge(_compare9, (int sorting_index) => { return values9[sorting_index]; }, (int sorting_index, Axis9 axis9) => { values9[sorting_index] = axis9; }, 0, (int)values1.Length);
                if (_defaultCompare10) Theta.Algorithms.Sort<Axis10>.Merge(Compare.Default, (int sorting_index) => { return values10[sorting_index]; }, (int sorting_index, Axis10 axis10) => { values10[sorting_index] = axis10; }, 0, (int)values1.Length);
                else Theta.Algorithms.Sort<Axis10>.Merge(_compare10, (int sorting_index) => { return values10[sorting_index]; }, (int sorting_index, Axis10 axis10) => { values10[sorting_index] = axis10; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index], values8[index], values9[index], values10[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> DetermineChildBounds(Branch branch, int child_index)
        {
            Omnitree.Bound<Axis10> min10, max10;
            if (child_index >= 1 << 2)
            {
                min10 = branch.PointOfDivision.Axis10;
                max10 = branch.Bounds.Max10;
                child_index -= 1 << 2;
            }
            else
            {
                min10 = branch.Bounds.Min10;
                max10 = branch.PointOfDivision.Axis10;
            }
            Omnitree.Bound<Axis9> min9, max9;
            if (child_index >= 1 << 2)
            {
                min9 = branch.PointOfDivision.Axis9;
                max9 = branch.Bounds.Max9;
                child_index -= 1 << 2;
            }
            else
            {
                min9 = branch.Bounds.Min9;
                max9 = branch.PointOfDivision.Axis9;
            }
            Omnitree.Bound<Axis8> min8, max8;
            if (child_index >= 1 << 2)
            {
                min8 = branch.PointOfDivision.Axis8;
                max8 = branch.Bounds.Max8;
                child_index -= 1 << 2;
            }
            else
            {
                min8 = branch.Bounds.Min8;
                max8 = branch.PointOfDivision.Axis8;
            }
            Omnitree.Bound<Axis7> min7, max7;
            if (child_index >= 1 << 2)
            {
                min7 = branch.PointOfDivision.Axis7;
                max7 = branch.Bounds.Max7;
                child_index -= 1 << 2;
            }
            else
            {
                min7 = branch.Bounds.Min7;
                max7 = branch.PointOfDivision.Axis7;
            }
            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 1 << 2)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 1 << 2;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }
            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 1 << 2)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 1 << 2;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }
            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 1 << 2)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 1 << 2;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }
            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 1 << 2)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 1 << 2;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }
            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 1 << 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 1 << 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }
            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1 << 2)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1 << 2;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Omnitree.Bound<Axis10> min10, Omnitree.Bound<Axis10> max10)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9, axis10, axis10));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9, Omnitree.Bound<Axis10> axis10)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9, axis10, axis10));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value, bounds.Min7.Value, bounds.Min8.Value, bounds.Min9.Value, bounds.Min10.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Omnitree.Bound<Axis10> min10, Omnitree.Bound<Axis10> max10)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9, axis10, axis10), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9, Omnitree.Bound<Axis10> axis10)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9, axis10, axis10), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Omnitree.Bound<Axis10> min10, Omnitree.Bound<Axis10> max10)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9, Omnitree.Bound<Axis10> axis10)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9, axis10, axis10));
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Omnitree.Bound<Axis10> min10, Omnitree.Bound<Axis10> max10, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="axis8">The coordinate along the 8D axis.</param>
		/// <param name="axis9">The coordinate along the 9D axis.</param>
		/// <param name="axis10">The coordinate along the 10D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7, Omnitree.Bound<Axis8> axis8, Omnitree.Bound<Axis9> axis9, Omnitree.Bound<Axis10> axis10, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, axis8, axis8, axis9, axis9, axis10, axis10), where);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            Axis8 axis8;
            Axis9 axis9;
            Axis10 axis10;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7, out axis8, out axis9, out axis10);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
		/// <param name="axis10">The axis of the removal along the  10D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
		/// <param name="axis10">The axis of the removal along the  10D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top);
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Omnitree.Bound<Axis10> min10, Omnitree.Bound<Axis10> max10)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Axis8 min8, Axis8 max8, Axis9 min9, Axis9 max9, Axis10 min10, Axis10 max10)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
            } while (status == StepStatus.Restart);
            return status;
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="min8">The minimum coordinate of the space along the 8 axis.</param>
		/// <param name="max8">The maximum coordinate of the space along the 8 axis.</param>
		/// <param name="min9">The minimum coordinate of the space along the 9 axis.</param>
		/// <param name="max9">The maximum coordinate of the space along the 9 axis.</param>
		/// <param name="min10">The minimum coordinate of the space along the 10 axis.</param>
		/// <param name="max10">The maximum coordinate of the space along the 10 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Omnitree.Bound<Axis8> min8, Omnitree.Bound<Axis8> max8, Omnitree.Bound<Axis9> min9, Omnitree.Bound<Axis9> max9, Omnitree.Bound<Axis10> min10, Omnitree.Bound<Axis10> max10)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7, min8, max8, min9, max9, min10, max10));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
		/// <param name="axis10">The axis of the removal along the  10D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="axis8">The axis of the removal along the  8D axis.</param>
		/// <param name="axis9">The axis of the removal along the  9D axis.</param>
		/// <param name="axis10">The axis of the removal along the  10D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Axis8 axis8, Axis9 axis9, Axis10 axis10)
        {
            StepStatus status;
            do
            {
                status = Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10));
            } while (status == StepStatus.Restart);
            return status;
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            if (bounds.Min1.Exists && bounds.Max1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater && (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less))
                return true;
            if (bounds.Min2.Exists && bounds.Max2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater && (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less))
                return true;
            if (bounds.Min3.Exists && bounds.Max3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater && (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less))
                return true;
            if (bounds.Min4.Exists && bounds.Max4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater && (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less))
                return true;
            if (bounds.Min5.Exists && bounds.Max5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater && (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less))
                return true;
            if (bounds.Min6.Exists && bounds.Max6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater && (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less))
                return true;
            if (bounds.Min7.Exists && bounds.Max7.Exists && this._compare7(bounds.Min7.Value, vector.Axis7) != Comparison.Greater && (this._compare7(bounds.Max7.Value, vector.Axis7) != Comparison.Less))
                return true;
            if (bounds.Min8.Exists && bounds.Max8.Exists && this._compare8(bounds.Min8.Value, vector.Axis8) != Comparison.Greater && (this._compare8(bounds.Max8.Value, vector.Axis8) != Comparison.Less))
                return true;
            if (bounds.Min9.Exists && bounds.Max9.Exists && this._compare9(bounds.Min9.Value, vector.Axis9) != Comparison.Greater && (this._compare9(bounds.Max9.Value, vector.Axis9) != Comparison.Less))
                return true;
            if (bounds.Min10.Exists && bounds.Max10.Exists && this._compare10(bounds.Min10.Value, vector.Axis10) != Comparison.Greater && (this._compare10(bounds.Max10.Value, vector.Axis10) != Comparison.Less))
                return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            if (!(this._compare7(vector.Axis7, pointOfDivision.Axis7) == Comparison.Less))
                child += 1 << 6;
            if (!(this._compare8(vector.Axis8, pointOfDivision.Axis8) == Comparison.Less))
                child += 1 << 7;
            if (!(this._compare9(vector.Axis9, pointOfDivision.Axis9) == Comparison.Less))
                child += 1 << 8;
            if (!(this._compare10(vector.Axis10, pointOfDivision.Axis10) == Comparison.Less))
                child += 1 << 9;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = new Leaf(removal.Bounds, removal.Parent, removal.Index);
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> b)
        {
            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;
            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;
            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;
            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;
            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;
            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;
            if (a.Max7.Exists && b.Min7.Exists && this._compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && this._compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;
            if (a.Max8.Exists && b.Min8.Exists && this._compare8(a.Max8.Value, b.Min8.Value) == Comparison.Less)
                return false;
            else if (a.Min8.Exists && b.Max8.Exists && this._compare8(a.Min8.Value, b.Max8.Value) == Comparison.Greater)
                return false;
            if (a.Max9.Exists && b.Min9.Exists && this._compare9(a.Max9.Value, b.Min9.Value) == Comparison.Less)
                return false;
            else if (a.Min9.Exists && b.Max9.Exists && this._compare9(a.Min9.Value, b.Max9.Value) == Comparison.Greater)
                return false;
            if (a.Max10.Exists && b.Min10.Exists && this._compare10(a.Max10.Value, b.Min10.Value) == Comparison.Less)
                return false;
            else if (a.Min10.Exists && b.Max10.Exists && this._compare10(a.Min10.Value, b.Max10.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            // if the location is not outside the bounds, it must be inside
            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;
            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;
            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;
            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;
            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;
            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;
            if (bounds.Min7.Exists && this._compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && this._compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;
            if (bounds.Min8.Exists && this._compare8(vector.Axis8, bounds.Min8.Value) == Comparison.Less)
                return false;
            else if (bounds.Max8.Exists && this._compare8(vector.Axis8, bounds.Max8.Value) == Comparison.Greater)
                return false;
            if (bounds.Min9.Exists && this._compare9(vector.Axis9, bounds.Min9.Value) == Comparison.Less)
                return false;
            else if (bounds.Max9.Exists && this._compare9(vector.Axis9, bounds.Max9.Value) == Comparison.Greater)
                return false;
            if (bounds.Min10.Exists && this._compare10(vector.Axis10, bounds.Min10.Value) == Comparison.Less)
                return false;
            else if (bounds.Max10.Exists && this._compare10(vector.Axis10, bounds.Max10.Value) == Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists) || (a.Min8.Exists && !b.Min8.Exists) || (a.Min9.Exists && !b.Min9.Exists) || (a.Min10.Exists && !b.Min10.Exists))
                return false;
            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;
            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;
            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;
            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;
            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;
            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;
            if (b.Min7.Exists && a.Min7.Exists && this._compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && this._compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;
            if (b.Min8.Exists && a.Min8.Exists && this._compare8(a.Min8.Value, b.Min8.Value) != Comparison.Less)
                return false;
            if (b.Max8.Exists && a.Max8.Exists && this._compare8(a.Max8.Value, b.Max8.Value) != Comparison.Greater)
                return false;
            if (b.Min9.Exists && a.Min9.Exists && this._compare9(a.Min9.Value, b.Min9.Value) != Comparison.Less)
                return false;
            if (b.Max9.Exists && a.Max9.Exists && this._compare9(a.Max9.Value, b.Max9.Value) != Comparison.Greater)
                return false;
            if (b.Min10.Exists && a.Min10.Exists && this._compare10(a.Min10.Value, b.Min10.Value) != Comparison.Less)
                return false;
            if (b.Max10.Exists && a.Max10.Exists && this._compare10(a.Max10.Value, b.Max10.Value) != Comparison.Greater)
                return false;
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> b)
        {
            if (!this._equate1(a.Axis1, b.Axis1))
                return false;
            if (!this._equate2(a.Axis2, b.Axis2))
                return false;
            if (!this._equate3(a.Axis3, b.Axis3))
                return false;
            if (!this._equate4(a.Axis4, b.Axis4))
                return false;
            if (!this._equate5(a.Axis5, b.Axis5))
                return false;
            if (!this._equate6(a.Axis6, b.Axis6))
                return false;
            if (!this._equate7(a.Axis7, b.Axis7))
                return false;
            if (!this._equate8(a.Axis8, b.Axis8))
                return false;
            if (!this._equate9(a.Axis9, b.Axis9))
                return false;
            if (!this._equate10(a.Axis10, b.Axis10))
                return false;
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            int natural_log = (int)Math.Log(count);
            this._depth_load = Compute<int>.Maximum(natural_log, _default_depth_load);
            //this._node_load = (int)Compute<int>.Maximum(natural_log, _children_per_node);
            this._node_load = (int)Compute<int>.Maximum(natural_log, 8);
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            Axis8 axis8;
            Axis9 axis9;
            Axis10 axis10;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7, out axis8, out axis9, out axis10);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9, Axis10>(axis1, axis2, axis3, axis4, axis5, axis6, axis7, axis8, axis9, axis10);
        }

        #endregion

        #endregion
    }

    #endregion
}